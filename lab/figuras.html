<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laboratorio de Geometría 3D Interactivo</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <!-- MathJax para renderizar fórmulas LaTeX -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        :root {
            --panel-bg: rgba(22, 33, 62, 0.6);
            --text-color: #e0fbfc;
            --title-color: #ffffff;
            --highlight-color: #e94560;
            --font-family: 'Poppins', sans-serif;
        }

        body {
            margin: 0;
            font-family: var(--font-family);
            color: var(--text-color);
            overflow: hidden;
            background: #1a1a2e;
        }
        
        body::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(circle at top left, #e94560, transparent 40%),
                        radial-gradient(circle at bottom right, #3498db, transparent 40%),
                        #1a1a2e;
            background-size: 200% 200%;
            animation: gradient-animation 20s ease infinite;
            z-index: -1;
        }

        @keyframes gradient-animation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .main-container { display: flex; width: 100vw; height: 100vh; }

        #info-panel {
            width: 320px;
            padding: 30px;
            background: var(--panel-bg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.2);
            z-index: 10;
            display: flex;
            flex-direction: column;
            transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        #info-panel h1 {
            font-size: 2em; font-weight: 600; color: var(--title-color);
            margin: 0 0 15px 0; border-bottom: 2px solid var(--highlight-color);
            padding-bottom: 15px;
        }

        #info-panel p { font-size: 1em; line-height: 1.7; font-weight: 300; }
        
        #category-tabs { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; }

        .tab-btn {
            padding: 8px 15px; border: 1px solid rgba(233, 69, 96, 0.5);
            background-color: rgba(233, 69, 96, 0.1); color: var(--highlight-color);
            border-radius: 20px; cursor: pointer; font-family: var(--font-family);
            font-weight: 400; transition: all 0.3s ease;
        }

        .tab-btn:hover, .tab-btn.active {
            background-color: var(--highlight-color); color: var(--title-color);
            box-shadow: 0 0 15px rgba(233, 69, 96, 0.5);
        }

        #controls-info { margin-top: auto; font-size: 0.85em; opacity: 0.6; }
        #controls-info strong { display: block; margin-bottom: 5px; font-weight: 400; }

        #info-content {
            margin-top: 25px; opacity: 0; transform: translateY(20px);
            transition: opacity 0.4s ease, transform 0.4s ease;
        }
        #info-content.visible { opacity: 1; transform: translateY(0); }
        #info-content h2 { color: var(--highlight-color); margin-top: 0; font-weight: 600; }
        .fun-fact { font-style: italic; font-size: 0.9em; opacity: 0.8; margin-top: 10px; }
        
        .formulas {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(224, 251, 252, 0.2);
        }
        .formulas h3 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            font-weight: 600;
            color: var(--title-color);
        }

        #interactive-controls { margin-top: 20px; }
        .control-btn {
            width: 100%; padding: 10px; margin-bottom: 10px;
            background-color: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            color: white; border-radius: 5px; cursor: pointer; transition: background-color 0.3s;
        }
        .control-btn:hover { background-color: rgba(255,255,255,0.2); }
        .slider-group { margin-top: 10px; }
        .slider-group label { display: block; margin-bottom: 5px; font-size: 0.9em; }
        .slider-group input { width: 100%; }

        #scene-container { flex-grow: 1; position: relative; cursor: grab; }
        #scene-container:active { cursor: grabbing; }
        canvas { display: block; width: 100%; height: 100%; }

        .label {
            color: var(--title-color); background: rgba(22, 33, 62, 0.7);
            padding: 5px 12px; border-radius: 20px; font-size: 14px;
            font-weight: 400; backdrop-filter: blur(5px);
            border: 1px solid rgba(224, 251, 252, 0.2); pointer-events: none;
        }

        @media (max-width: 768px) {
            .main-container { flex-direction: column-reverse; }
            #info-panel {
                width: 100%; height: 250px; box-sizing: border-box;
                border-left: none; border-top: 1px solid rgba(255, 255, 255, 0.1);
                box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.2);
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div id="info-panel">
            <h1>Geometría 3D</h1>
            <p>Selecciona una categoría para explorar las figuras.</p>
            <div id="category-tabs">
                <button class="tab-btn active" data-category="polyhedrons">Poliedros</button>
                <button class="tab-btn" data-category="round_bodies">Cuerpos Redondos</button>
                <button class="tab-btn" data-category="figures2d">Figuras 2D</button>
                <button class="tab-btn" data-category="fractals">Fractales</button>
            </div>
            <div id="info-content"></div>
            <div id="controls-info">
                <strong>Controles:</strong>
                <span>- <b>Arrastrar:</b> Rotar</span><br>
                <span>- <b>Rueda:</b> Zoom</span><br>
                <span>- <b>Click derecho:</b> Mover</span>
            </div>
        </div>
        <div id="scene-container"></div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        let scene, camera, renderer, labelRenderer, controls, composer;
        let figures = [], hoveredObject = null, selectedObject = null, particles;
        let isExploded = false, isWireframe = false;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const sceneContainer = document.getElementById('scene-container');
        const infoContent = document.getElementById('info-content');
        const clock = new THREE.Clock();
        const pointLight = new THREE.PointLight(0xffffff, 50, 100);
        let cameraTargetPos = new THREE.Vector3(), cameraTargetLookAt = new THREE.Vector3();
        let isAnimatingCamera = false;

        const allGeometries = {
            polyhedrons: [
                { geo: () => new THREE.BoxGeometry(1.8, 1.8, 1.8), name: 'Cubo', color: 0x3498db, info: 'Un hexaedro regular con 6 caras cuadradas.', fact: 'El Cubo de Rubik tiene más de 43 quintillones de permutaciones posibles.', formulas: 'Área: \\(A = 6a^2\\)<br>Volumen: \\(V = a^3\\)' },
                { geo: () => new THREE.TetrahedronGeometry(1.5), name: 'Tetraedro', color: 0x2ecc71, info: 'Un poliedro con 4 caras triangulares.', fact: 'Es la estructura del diamante a nivel molecular.', formulas: 'Área: \\(A = \\sqrt{3}a^2\\)<br>Volumen: \\(V = \\frac{\\sqrt{2}}{12}a^3\\)' },
                { geo: () => new THREE.OctahedronGeometry(1.5), name: 'Octaedro', color: 0xe74c3c, info: 'Un poliedro con 8 caras triangulares.', fact: 'Algunos cristales como la fluorita crecen naturalmente en forma de octaedros.', formulas: 'Área: \\(A = 2\\sqrt{3}a^2\\)<br>Volumen: \\(V = \\frac{\\sqrt{2}}{3}a^3\\)' },
                { geo: () => new THREE.DodecahedronGeometry(1.5), name: 'Dodecaedro', color: 0x9b59b6, info: 'Un poliedro con 12 caras pentagonales.', fact: 'Platón lo asociaba con el universo o el cosmos.', formulas: 'Área: \\(A \\approx 20.65a^2\\)<br>Volumen: \\(V \\approx 7.66a^3\\)' },
                { geo: () => new THREE.IcosahedronGeometry(1.5), name: 'Icosaedro', color: 0xf1c40f, info: 'Un poliedro con 20 caras triangulares.', fact: 'Muchos virus, como el del resfriado común, tienen forma de icosaedro.', formulas: 'Área: \\(A = 5\\sqrt{3}a^2\\)<br>Volumen: \\(V \\approx 2.18a^3\\)' },
            ],
            round_bodies: [
                { geo: () => new THREE.SphereGeometry(1.2, 32, 32), name: 'Esfera', color: 0xe74c3c, info: 'Una superficie perfectamente redonda.', fact: 'Es la forma que minimiza la superficie para un volumen dado.', formulas: 'Área: \\(A = 4\\pi r^2\\)<br>Volumen: \\(V = \\frac{4}{3}\\pi r^3\\)' },
                { geo: (p = {h: 2.5}) => new THREE.CylinderGeometry(1, 1, p.h, 32), name: 'Cilindro', color: 0x2ecc71, info: 'Tiene 2 caras circulares planas y una cara curva.', fact: 'Las latas de refresco son un ejemplo común de cilindros en la vida diaria.', params: { h: { min: 1, max: 5, step: 0.1, val: 2.5, label: 'Altura' } }, formulas: 'Área: \\(A = 2\\pi r(r + h)\\)<br>Volumen: \\(V = \\pi r^2h\\)' },
                { geo: (p = {r: 1, t: 0.4}) => new THREE.TorusGeometry(p.r, p.t, 16, 100), name: 'Toro (Dona)', color: 0x3498db, info: 'Una figura generada al girar un círculo alrededor de un eje.', fact: 'El universo podría tener forma de un toro tridimensional.', params: { r: { min: 0.5, max: 2, step: 0.1, val: 1, label: 'Radio' }, t: { min: 0.1, max: 0.8, step: 0.05, val: 0.4, label: 'Grosor' } }, formulas: 'Área: \\(A = 4\\pi^2 Rr\\)<br>Volumen: \\(V = 2\\pi^2 Rr^2\\)' },
                { geo: () => new THREE.TorusKnotGeometry(1, 0.3, 100, 16), name: 'Nudo de Toro', color: 0x9b59b6, info: 'Una forma más compleja de toro anudado.', fact: 'Se usa a menudo en gráficos por computadora para probar materiales y luces.', formulas: 'Sus fórmulas son muy complejas y se basan en ecuaciones paramétricas.' },
                { geo: () => new THREE.CapsuleGeometry(0.8, 1.5, 4, 8), name: 'Cápsula', color: 0xf1c40f, info: 'Un cilindro con dos hemisferios en los extremos.', fact: 'Esta forma es común en píldoras y farmacéuticos por su facilidad para tragar.', formulas: 'Área: \\(A = 4\\pi r^2 + 2\\pi rh\\)<br>Volumen: \\(V = \\frac{4}{3}\\pi r^3 + \\pi r^2h\\)'}
            ],
            figures2d: [
                { geo: () => new THREE.PlaneGeometry(2, 2), name: 'Cuadrado', color: 0x9b59b6, info: 'Figura plana con 4 lados iguales.', fact: 'Es una de las formas más utilizadas en el arte del pixel art.', formulas: 'Área: \\(A = l^2\\)' },
                { geo: () => new THREE.CircleGeometry(1.2, 32), name: 'Círculo', color: 0xf1c40f, info: 'Una forma redonda sin esquinas ni lados.', fact: 'El número Pi (π) es fundamental para calcular su área y perímetro.', formulas: 'Área: \\(A = \\pi r^2\\)<br>Perímetro: \\(P = 2\\pi r\\)' },
                { geo: () => new THREE.RingGeometry(0.8, 1.2, 32), name: 'Anillo', color: 0xe74c3c, info: 'El área entre dos círculos concéntricos.', fact: 'Los anillos de Saturno están compuestos por miles de millones de anillos más pequeños.', formulas: 'Área: \\(A = \\pi (R^2 - r^2)\\)' },
                { geo: () => new THREE.CircleGeometry(1.2, 6), name: 'Hexágono', color: 0x2ecc71, info: 'Un polígono de seis lados y seis vértices.', fact: 'Las abejas construyen sus panales con celdas hexagonales, la forma más eficiente de almacenar miel.', formulas: 'Área: \\(A = \\frac{3\\sqrt{3}}{2}a^2\\)'},
                { geo: () => {
                    const shape = new THREE.Shape();
                    const outerRadius = 1.2, innerRadius = 0.6, points = 5;
                    shape.moveTo(0, outerRadius);
                    for (let i = 0; i < points * 2; i++) {
                        const radius = i % 2 === 0 ? outerRadius : innerRadius;
                        const angle = (i / (points * 2)) * Math.PI * 2;
                        shape.lineTo(Math.sin(angle) * radius, Math.cos(angle) * radius);
                    }
                    shape.closePath();
                    return new THREE.ShapeGeometry(shape);
                }, name: 'Estrella', color: 0x3498db, info: 'Un polígono con picos que irradian desde un centro.', fact: 'La estrella de cinco puntas es un símbolo con profundos significados en muchas culturas.', formulas: 'El cálculo de su área depende del tipo de estrella.'}
            ]
        };

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, sceneContainer.clientWidth / sceneContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, 3, 14);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            sceneContainer.appendChild(renderer.domElement);

            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            sceneContainer.appendChild(labelRenderer.domElement);
            
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1;
            bloomPass.strength = 0.6;
            bloomPass.radius = 0.3;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.dampingFactor = 0.05;
            controls.minDistance = 5; controls.maxDistance = 50;
            controls.target.set(0, 1, 0);

            const ambientLight = new THREE.AmbientLight(0xe0fbfc, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(10, 15, 10);
            scene.add(directionalLight);
            scene.add(pointLight);

            createParticles();
            setupEventListeners();
            switchCategory('polyhedrons');
            animate();
        }

        function createParticles() {
            const particleCount = 2000;
            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 50;
            }
            const particlesGeometry = new THREE.BufferGeometry();
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const particlesMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05, transparent: true, opacity: 0.5 });
            particles = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particles);
        }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            sceneContainer.addEventListener('click', onClick);
            sceneContainer.addEventListener('mousemove', onMouseMove);
            
            document.querySelectorAll('.tab-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const category = e.target.dataset.category;
                    switchCategory(category);
                    document.querySelector('.tab-btn.active').classList.remove('active');
                    e.target.classList.add('active');
                });
            });
        }

        function clearScene() {
            while(figures.length > 0){ 
                const fig = figures.pop();
                fig.children.filter(c => c.isCSS2DObject).forEach(label => fig.remove(label));
                scene.remove(fig);
            }
            for (let i = scene.children.length - 1; i >= 0; i--) {
                const obj = scene.children[i];
                if ((obj.isMesh || obj.isGroup) && obj !== particles) scene.remove(obj);
            }
        }
        
        function switchCategory(category) {
            clearScene();
            updateInfoPanel(null);
            selectedObject = null;
            cameraTargetPos.set(0, 3, 14);
            cameraTargetLookAt.set(0, 1, 0);
            isAnimatingCamera = true;
            if (category === 'fractals') createFractal();
            else createFigures(category);
        }

        function createFigures(category) {
            const items = allGeometries[category];
            const spacing = 4.5;
            items.forEach((item, index) => {
                const material = new THREE.MeshPhysicalMaterial({
                    color: item.color, metalness: 0.1, roughness: 0.1,
                    transmission: 0.8, ior: 1.5, thickness: 1.5,
                    side: THREE.DoubleSide
                });
                const mesh = new THREE.Mesh(item.geo(), material);
                mesh.position.x = (index - (items.length - 1) / 2) * spacing;
                
                mesh.userData = { ...item, originalMaterial: material, wireframeMaterial: new THREE.MeshBasicMaterial({ color: item.color, wireframe: true }) };
                
                const positions = mesh.geometry.attributes.position.array;
                mesh.userData.originalPositions = new Float32Array(positions);

                scene.add(mesh);
                figures.push(mesh);
                const labelDiv = document.createElement('div');
                labelDiv.className = 'label';
                labelDiv.textContent = item.name;
                const label = new CSS2DObject(labelDiv);
                label.position.set(0, 1.8, 0);
                mesh.add(label);
            });
        }
        
        function createFractal() {
            const fractalGroup = new THREE.Group();
            const material = new THREE.MeshPhysicalMaterial({
                color: 0xff00ff, metalness: 0.1, roughness: 0.05,
                transmission: 0.9, ior: 1.5, thickness: 1.5
            });
            const baseGeometry = new THREE.ConeGeometry(2, 3, 4);
            function buildSierpinski(depth, size, position) {
                if (depth === 0) {
                    const pyramid = new THREE.Mesh(baseGeometry, material);
                    pyramid.scale.set(size, size, size);
                    pyramid.position.copy(position);
                    fractalGroup.add(pyramid);
                    return;
                }
                const newSize = size * 0.5, newDepth = depth - 1, offset = newSize * 1.5;
                buildSierpinski(newDepth, newSize, position.clone().add(new THREE.Vector3(0, offset, 0)));
                const angleStep = (Math.PI * 2) / 4;
                for (let i = 0; i < 4; i++) {
                    const angle = angleStep * i + Math.PI / 4;
                    const x = Math.cos(angle) * offset, z = Math.sin(angle) * offset;
                    buildSierpinski(newDepth, newSize, position.clone().add(new THREE.Vector3(x, -offset*0.5, z)));
                }
            }
            buildSierpinski(3, 1, new THREE.Vector3(0, 0, 0));
            fractalGroup.userData = { name: 'Fractal de Sierpinski', info: 'Un fractal es un objeto geométrico cuya estructura básica se repite a diferentes escalas.', fact: 'Los fractales se encuentran en la naturaleza, como en los copos de nieve y los helechos.' };
            scene.add(fractalGroup);
            figures.push(fractalGroup);
        }

        function updateRaycaster(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
        }

        function onMouseMove(event) {
            updateRaycaster(event);
            const intersects = raycaster.intersectObjects(scene.children, true);
            const object = intersects.length > 0 ? (intersects[0].object.parent.isGroup ? intersects[0].object.parent : intersects[0].object) : null;
            if (hoveredObject !== object && figures.includes(object)) {
                if (hoveredObject) hoveredObject.scale.set(1, 1, 1);
                hoveredObject = object;
                hoveredObject.scale.set(1.15, 1.15, 1.15);
            } else if (!object && hoveredObject) {
                hoveredObject.scale.set(1, 1, 1);
                hoveredObject = null;
            }
            const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5).unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            pointLight.position.copy(camera.position).add(dir.multiplyScalar(distance));
        }

        function onClick(event) {
            updateRaycaster(event);
            const intersects = raycaster.intersectObjects(scene.children, true);
            if (intersects.length > 0) {
                const clickedObject = intersects[0].object.parent.isGroup ? intersects[0].object.parent : intersects[0].object;
                if (figures.includes(clickedObject) && selectedObject !== clickedObject) {
                    if (selectedObject) {
                        selectedObject.material = selectedObject.userData.originalMaterial;
                    }
                    selectedObject = clickedObject;
                    isWireframe = false;
                    isExploded = false;
                    updateInfoPanel(selectedObject.userData);
                    
                    const targetPosition = new THREE.Vector3();
                    selectedObject.getWorldPosition(targetPosition);
                    cameraTargetLookAt.copy(targetPosition);
                    
                    const offset = new THREE.Vector3(0, 1, 5);
                    cameraTargetPos.copy(targetPosition).add(offset);
                    isAnimatingCamera = true;
                }
            } else {
                if (selectedObject) {
                    selectedObject.material = selectedObject.userData.originalMaterial;
                }
                selectedObject = null;
                updateInfoPanel(null);
                cameraTargetPos.set(0, 3, 14);
                cameraTargetLookAt.set(0, 1, 0);
                isAnimatingCamera = true;
            }
        }
        
        function updateInfoPanel(data) {
            infoContent.classList.remove('visible');
            setTimeout(() => {
                if (data) {
                    let html = `<h2>${data.name}</h2><p>${data.info}</p>`;
                    if (data.fact) html += `<p class="fun-fact"><b>Sabías que...</b> ${data.fact}</p>`;
                    
                    if (data.formulas) {
                        html += `<div class="formulas"><h3>Fórmulas</h3><p>${data.formulas}</p></div>`;
                    }

                    if (data.name !== 'Fractal de Sierpinski') {
                         html += `<div id="interactive-controls">
                            <button id="explode-btn" class="control-btn">Explosionar Vista</button>
                            <button id="wireframe-btn" class="control-btn">Modo Esqueleto</button>
                        </div>`;
                    }

                    if (data.params) {
                        html += '<div class="slider-group">';
                        for (const key in data.params) {
                            const p = data.params[key];
                            html += `<label for="${key}-slider">${p.label}</label>
                                     <input type="range" id="${key}-slider" min="${p.min}" max="${p.max}" step="${p.step}" value="${p.val}">`;
                        }
                        html += '</div>';
                    }

                    infoContent.innerHTML = html;
                    if (window.MathJax) {
                        window.MathJax.typesetPromise([infoContent]);
                    }
                    infoContent.classList.add('visible');
                    addInteractiveListeners(data);
                } else {
                    infoContent.innerHTML = '';
                }
            }, 200);
        }
        
        function addInteractiveListeners(data) {
            document.getElementById('explode-btn')?.addEventListener('click', toggleExplosion);
            document.getElementById('wireframe-btn')?.addEventListener('click', toggleWireframe);
            
            if (data.params) {
                for (const key in data.params) {
                    document.getElementById(`${key}-slider`).addEventListener('input', (e) => {
                        const newParams = {};
                        for (const k in data.params) {
                            newParams[k] = document.getElementById(`${k}-slider`).value;
                        }
                        const newGeo = data.geo(newParams);
                        selectedObject.geometry.dispose();
                        selectedObject.geometry = newGeo;
                        selectedObject.userData.originalPositions = new Float32Array(newGeo.attributes.position.array);
                    });
                }
            }
        }

        function toggleExplosion() {
            if (!selectedObject) return;
            isExploded = !isExploded;
            document.getElementById('explode-btn').textContent = isExploded ? 'Reconstruir Vista' : 'Explosionar Vista';
        }
        
        function toggleWireframe() {
            if (!selectedObject) return;
            isWireframe = !isWireframe;
            selectedObject.material = isWireframe ? selectedObject.userData.wireframeMaterial : selectedObject.userData.originalMaterial;
            document.getElementById('wireframe-btn').textContent = isWireframe ? 'Modo Sólido' : 'Modo Esqueleto';
        }

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();

            if (particles) particles.rotation.y = elapsedTime * 0.05;

            if (isAnimatingCamera) {
                camera.position.lerp(cameraTargetPos, 0.05);
                controls.target.lerp(cameraTargetLookAt, 0.05);
                if (camera.position.distanceTo(cameraTargetPos) < 0.1) isAnimatingCamera = false;
            }

            if (selectedObject && selectedObject.geometry.attributes.position && selectedObject.userData.name !== 'Fractal de Sierpinski') {
                const positions = selectedObject.geometry.attributes.position.array;
                const originalPos = selectedObject.userData.originalPositions;
                const explosionFactor = isExploded ? 1.5 : 1.0;
                for (let i = 0; i < positions.length; i += 3) {
                    const ox = originalPos[i], oy = originalPos[i+1], oz = originalPos[i+2];
                    const targetX = ox * explosionFactor, targetY = oy * explosionFactor, targetZ = oz * explosionFactor;
                    positions[i] += (targetX - positions[i]) * 0.1;
                    positions[i+1] += (targetY - positions[i+1]) * 0.1;
                    positions[i+2] += (targetZ - positions[i+2]) * 0.1;
                }
                selectedObject.geometry.attributes.position.needsUpdate = true;
            }

            figures.forEach(figure => {
                if (figure !== selectedObject) {
                    figure.position.y = Math.sin(elapsedTime * 0.5 + figure.position.x) * 0.2;
                    figure.rotation.y += 0.002;
                    figure.rotation.x += 0.001;
                }
            });

            controls.update();
            composer.render();
            labelRenderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = sceneContainer.clientWidth / sceneContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
            composer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
            labelRenderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
        }

        init();
    </script>
</body>
</html>
