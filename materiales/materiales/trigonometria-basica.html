<!DOCTYPE html>
<html lang="es-PR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Examen de Funciones Trigonom√©tricas B√°sicas</title>
    
    <!-- MathJax v3 Configuration -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']],
                displayMath: [['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

    <!-- CSS Styles -->
    <style>
        :root {
            --bg-color: #fdfbf7;
            --dot-color: #e0ddd7;
            --text-color: #1c1917;
            --accent-green: #166534;
            --accent-orange: #f97316;
            --accent-blue: #155e75;
            --card-bg: #fffbeb;
            --tape-color: rgba(255, 237, 180, 0.5);
            --correct-bg: #dcfce7;
            --incorrect-bg: #fee2e2;
            --correct-text: #166534;
            --incorrect-text: #991b1b;
            --font-family: 'Syne', -apple-system, sans-serif;
        }

        /* Basic Setup & Dot Grid Background */
        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            background-image:
                radial-gradient(var(--dot-color) 1px, transparent 1px);
            background-size: 1.5rem 1.5rem;
            display: flex;
            min-height: 100vh;
            line-height: 1.6;
        }

        /* Main Layout: Sidebar + Content */
        .sidebar {
            width: 250px;
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(5px);
            border-right: 1px solid var(--dot-color);
            position: fixed;
            top: 0;
            left: 0;
            bottom: 0;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            overflow-y: auto;
        }

        .main-content {
            margin-left: 250px;
            flex-grow: 1;
            padding: 2rem 3rem;
        }

        /* Typography */
        h1, h2, h3 {
            font-weight: 700;
            margin-top: 0;
            color: var(--accent-blue);
        }
        h1 { font-size: 2rem; }
        h2 { font-size: 1.5rem; border-bottom: 2px solid var(--dot-color); padding-bottom: 0.5rem; margin-bottom: 1.5rem; }
        h3 { font-size: 1.25rem; color: var(--accent-green); }

        /* Stepper Navigation */
        .stepper {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .stepper li {
            margin-bottom: 0.5rem;
        }
        .stepper a {
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            text-decoration: none;
            color: var(--text-color);
            font-weight: 500;
            transition: all 0.2s ease-in-out;
            border: 2px solid transparent;
        }
        .stepper a .q-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: var(--dot-color);
            color: var(--accent-blue);
            font-weight: 700;
            margin-right: 1rem;
            transition: all 0.2s ease-in-out;
        }
        .stepper a:hover {
            background-color: var(--card-bg);
        }
        .stepper a.active {
            background-color: var(--accent-orange);
            color: white;
            border-color: #c2410c;
        }
        .stepper a.active .q-number {
            background-color: white;
            color: var(--accent-orange);
        }
        .stepper a.answered .q-number {
            background-color: var(--accent-blue);
            color: white;
        }
        .stepper a.correct .q-number { background-color: var(--correct-text); color: white; }
        .stepper a.incorrect .q-number { background-color: var(--incorrect-text); color: white; }


        /* Question Card (Sticky Note Style) */
        .question-card {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 4px;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            position: relative;
            border: 1px solid #fde68a;
            transform: rotate(-1deg);
            transition: transform 0.2s ease-in-out;
        }
        .question-card:nth-child(odd) { transform: rotate(0.8deg); }
        .question-card:hover { transform: rotate(0deg) scale(1.01); z-index: 10; }

        .question-card::before, .question-card::after {
            content: '';
            position: absolute;
            width: 100px;
            height: 30px;
            background-color: var(--tape-color);
            box-shadow: 0 1px 1px rgba(0,0,0,0.1);
            border-left: 1px dashed rgba(0,0,0,0.1);
            border-right: 1px dashed rgba(0,0,0,0.1);
        }
        .question-card::before {
            top: -15px;
            left: -15px;
            transform: rotate(-35deg);
        }
        .question-card::after {
            top: -10px;
            right: -20px;
            transform: rotate(25deg);
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        .category-badge {
            background-color: var(--accent-blue);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        .question-content {
            display: flex;
            gap: 2rem;
            align-items: center;
        }
        .question-svg {
            flex-shrink: 0;
            width: 280px;
            height: 280px;
            background: rgba(255,255,255,0.8);
            border-radius: 8px;
            border: 1px solid var(--dot-color);
            padding: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .question-svg svg {
            max-width: 100%;
            max-height: 100%;
        }
        .question-body {
            flex-grow: 1;
        }
        .question-body .enunciado { font-size: 1.1rem; margin-bottom: 1rem; }
        .question-body .input-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .question-body label {
            font-weight: 600;
            color: var(--accent-green);
        }
        .question-body input {
            padding: 0.75rem;
            border: 2px solid var(--dot-color);
            border-radius: 8px;
            font-size: 1rem;
            font-family: var(--font-family);
            transition: border-color 0.2s, box-shadow 0.2s;
            background: white;
            width: 250px;
        }
        .question-body input:focus {
            outline: none;
            border-color: var(--accent-orange);
            box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.2);
        }

        /* Feedback Styles */
        .feedback {
            margin-top: 1rem;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-weight: 500;
            min-height: 24px;
            transition: opacity 0.3s;
        }
        .feedback.correct {
            background-color: var(--correct-bg);
            color: var(--correct-text);
            border: 1px solid var(--correct-text);
        }
        .feedback.incorrect {
            background-color: var(--incorrect-bg);
            color: var(--incorrect-text);
            border: 1px solid var(--incorrect-text);
        }

        /* Buttons */
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }
        .btn-primary {
            background-color: var(--accent-orange);
            color: white;
            border: 2px solid #c2410c;
        }
        .btn-primary:hover { background-color: #ea580c; }
        
        .btn-secondary {
            background-color: var(--accent-green);
            color: white;
            border: 2px solid #14532d;
        }
        .btn-secondary:hover { background-color: #15803d; }
        
        .btn-tertiary {
            background-color: #e0e0e0;
            color: #333;
            border: 2px solid #b0b0b0;
        }
        .btn-tertiary:hover { background-color: #d0d0d0; }

        /* Control Sections */
        .exam-controls, .results-section, .initial-screen {
            background-color: #fff;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            text-align: center;
            margin-bottom: 2rem;
        }
        
        #results-section .button-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        
        /* History Table */
        #history-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            text-align: left;
        }
        #history-table th, #history-table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--dot-color);
        }
        #history-table th {
            background-color: var(--bg-color);
            font-weight: 600;
        }

        /* Helper Panel */
        details {
            background: var(--card-bg);
            border: 1px solid #fde68a;
            border-radius: 8px;
            padding: 0.5rem 1rem;
            margin-top: 2rem;
        }
        details summary {
            font-weight: 600;
            cursor: pointer;
            color: var(--accent-green);
        }
        .gallery {
            display: flex;
            gap: 1.5rem;
            margin-top: 1rem;
            overflow-x: auto;
            padding-bottom: 1rem;
        }
        .gallery-item { text-align: center; }
        .gallery-item svg { width: 200px; height: 150px; background: white; border-radius: 4px; border: 1px solid var(--dot-color); }
        
        /* Utility & Accessibility */
        .hidden { display: none !important; }
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            body { flex-direction: column; }
            .sidebar {
                position: static;
                width: 100%;
                height: auto;
                flex-direction: row;
                flex-wrap: wrap;
                align-items: center;
                border-right: none;
                border-bottom: 1px solid var(--dot-color);
            }
            .sidebar h2 { display: none; }
            .stepper { display: flex; flex-wrap: wrap; gap: 0.5rem; }
            .stepper a .q-text { display: none; }
            .main-content { margin-left: 0; padding: 1.5rem; }
            .question-content { flex-direction: column; }
            .question-svg { width: 100%; max-width: 300px; height: auto; }
        }

        @media (max-width: 768px) {
            .question-card::before, .question-card::after { display: none; }
            .question-card { transform: rotate(0) !important; }
            .question-body input { width: 100%; }
        }
        
        /* Print Styles */
        @media print {
            body {
                background-image: none;
                display: block;
            }
            .sidebar, .exam-controls, #results-section, #helper-gallery, footer, .question-card::before, .question-card::after {
                display: none;
            }
            .main-content {
                margin-left: 0;
                padding: 0;
            }
            #print-container {
                display: block !important;
                font-family: 'Times New Roman', serif;
            }
            .print-header h1 {
                text-align: center;
                font-size: 24pt;
            }
            .print-question {
                page-break-inside: avoid;
                margin-bottom: 1.5rem;
                border: 1px solid #ccc;
                padding: 1rem;
                border-radius: 8px;
            }
             .print-question svg {
                max-width: 250px;
                display: block;
                margin: 0 auto;
            }
            h1, h2, h3, p, div {
                color: #000 !important;
                background-color: transparent !important;
            }
            a { text-decoration: none; }
        }
        #print-container { display: none; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Syne:wght@400;500;600;700;800&family=DM+Mono:wght@400;500&display=swap" rel="stylesheet">
</head>
<body>

    <aside class="sidebar">
        <div>
            <h2>Navegaci√≥n</h2>
            <p id="exam-timer" aria-live="polite">Tiempo: 00:00</p>
        </div>
        <nav aria-label="Navegaci√≥n de Preguntas">
            <ol class="stepper" id="stepper"></ol>
        </nav>
    </aside>

    <main class="main-content">
        <header>
            <h1>Examen de Funciones Trigonom√©tricas B√°sicas</h1>
        </header>

        <section id="initial-screen">
            <h2>Instrucciones</h2>
            <p>Este examen contiene 12 preguntas de opci√≥n m√∫ltiple y respuesta corta sobre funciones trigonom√©tricas.</p>
            <p>Puedes intentarlo cuantas veces desees. No se mostrar√°n las respuestas correctas, solo si tu contestaci√≥n es correcta o incorrecta y una pista.</p>
            <div style="margin: 1.5rem 0;">
                <label for="student-name" style="margin-right: 0.5rem; font-weight: 600;">Nombre del estudiante (opcional):</label>
                <input type="text" id="student-name" placeholder="Escribe tu nombre" style="padding: 0.5rem; border-radius: 4px; border: 1px solid #ccc;">
            </div>
            <button id="start-btn" class="btn btn-primary">Iniciar Examen</button>
        </section>

        <form id="exam-form" class="hidden">
            <div id="questions-container"></div>
            <div class="exam-controls">
                <button type="submit" id="submit-btn" class="btn btn-secondary">Enviar Examen</button>
            </div>
        </form>

        <section id="results-section" class="hidden">
            <h2>Resultados</h2>
            <div id="summary"></div>
            <div class="button-group">
                <button id="retry-btn" class="btn btn-primary">Reintentar</button>
                <button id="copy-summary-btn" class="btn btn-tertiary">Copiar Resumen</button>
            </div>
            <h3>Exportar Resultados</h3>
             <div class="button-group">
                <button id="csv-btn" class="btn btn-tertiary">Descargar CSV</button>
                <button id="json-btn" class="btn btn-tertiary">Descargar JSON</button>
                <button id="pdf-btn" class="btn btn-tertiary">Descargar PDF</button>
            </div>
            <h3>Historial de Intentos (√∫ltimos 5)</h3>
            <table id="history-table">
                <thead>
                    <tr>
                        <th>Fecha y Hora</th>
                        <th>Puntuaci√≥n</th>
                        <th>Duraci√≥n</th>
                    </tr>
                </thead>
                <tbody id="history-body"></tbody>
            </table>
        </section>

        <details id="helper-gallery">
            <summary>üìö Galer√≠a de Gr√°ficas Base</summary>
            <div class="gallery" id="gallery-container"></div>
        </details>
        
        <footer>
            <p style="text-align: center; color: #777; margin-top: 2rem;">Herramienta de pr√°ctica creada con fines educativos.</p>
        </footer>

    </main>
    
    <!-- This container is only used for printing -->
    <div id="print-container"></div>


    <!-- JavaScript Logic -->
    <script>
    document.addEventListener('DOMContentLoaded', () => {

        // IIFE to encapsulate the entire application
        (function() {
            // --- STATE MANAGEMENT ---
            const state = {
                questions: [],
                currentAttempt: [],
                userAnswers: {},
                startTime: null,
                endTime: null,
                timerInterval: null,
                history: [],
                studentName: ''
            };

            // --- DOM ELEMENTS ---
            const initialScreen = document.getElementById('initial-screen');
            const examForm = document.getElementById('exam-form');
            const startBtn = document.getElementById('start-btn');
            const submitBtn = document.getElementById('submit-btn');
            const retryBtn = document.getElementById('retry-btn');
            const questionsContainer = document.getElementById('questions-container');
            const stepper = document.getElementById('stepper');
            const resultsSection = document.getElementById('results-section');
            const summaryDiv = document.getElementById('summary');
            const examTimer = document.getElementById('exam-timer');
            const historyBody = document.getElementById('history-body');
            const studentNameInput = document.getElementById('student-name');
            const copySummaryBtn = document.getElementById('copy-summary-btn');
            const csvBtn = document.getElementById('csv-btn');
            const jsonBtn = document.getElementById('json-btn');
            const pdfBtn = document.getElementById('pdf-btn');

            // --- CONSTANTS ---
            const EPSILON = 1e-6;
            const NUM_QUESTIONS = 12;

            // --- UTILITY FUNCTIONS ---
            const shuffleArray = (array) => array.sort(() => Math.random() - 0.5);
            const degToRad = (deg) => deg * Math.PI / 180;
            const radToDeg = (rad) => rad * 180 / Math.PI;
            const formatTime = (seconds) => {
                const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
                const secs = (seconds % 60).toString().padStart(2, '0');
                return `${mins}:${secs}`;
            };
            const toFixedFloat = (num, precision = 4) => parseFloat(num.toFixed(precision));

            // --- PARSING & EVALUATION ---
            const TRIG_VALUES_MAP = {
                'sqrt(3)/2': Math.sqrt(3) / 2, '‚àö3/2': Math.sqrt(3) / 2,
                'sqrt(2)/2': Math.sqrt(2) / 2, '‚àö2/2': Math.sqrt(2) / 2,
                '1/2': 0.5,
                '-sqrt(3)/2': -Math.sqrt(3) / 2, '-‚àö3/2': -Math.sqrt(3) / 2,
                '-sqrt(2)/2': -Math.sqrt(2) / 2, '-‚àö2/2': -Math.sqrt(2) / 2,
                '-1/2': -0.5,
                'sqrt(3)': Math.sqrt(3), '‚àö3': Math.sqrt(3),
                '-sqrt(3)': -Math.sqrt(3), '-‚àö3': -Math.sqrt(3),
                '1': 1, '0': 0, '-1': -1,
            };

            function mapExactTrig(str) {
                const cleanedStr = str.trim().replace(/\s/g, '');
                return TRIG_VALUES_MAP[cleanedStr];
            }

            function parseNumberOrFraction(str) {
                str = str.trim();
                if (str.includes('/')) {
                    const parts = str.split('/');
                    if (parts.length === 2) {
                        const num = parseFloat(parts[0]);
                        const den = parseFloat(parts[1]);
                        if (!isNaN(num) && !isNaN(den) && den !== 0) {
                            return num / den;
                        }
                    }
                }
                return parseFloat(str);
            }

            function parsePiFraction(str) {
                str = str.trim().toLowerCase().replace('œÄ', 'pi');
                let multiplier = 1;
                
                if (str.startsWith('-')) {
                    multiplier = -1;
                    str = str.substring(1);
                }

                if (str === 'pi') return multiplier * Math.PI;

                if (str.includes('pi')) {
                    if (str.startsWith('pi')) {
                        str = '1' + str;
                    }
                    const parts = str.split('pi');
                    let numPart = parts[0].replace('*', '').trim();
                    let denPart = parts.length > 1 && parts[1] ? parts[1].replace('/', '').trim() : '1';
                    
                    let num = numPart === '' ? 1 : parseNumberOrFraction(numPart);
                    let den = denPart === '' ? 1 : parseNumberOrFraction(denPart);

                    if (!isNaN(num) && !isNaN(den) && den !== 0) {
                        return multiplier * num * Math.PI / den;
                    }
                }
                return parseFloat(str);
            }

            function compareValues(val1, val2, type) {
                if (type === 'text') {
                    return val1.toString().trim().toLowerCase() === val2.toString().trim().toLowerCase();
                }
                
                const num1 = parseFloat(val1);
                const num2 = parseFloat(val2);

                if (isNaN(num1) || isNaN(num2)) return false;

                return Math.abs(num1 - num2) < EPSILON;
            }

            function evaluateAnswer(userAnswerStr, solution, type) {
                let parsedAnswer;
                const cleanedStr = userAnswerStr.trim().toLowerCase();

                if (type === 'text') {
                    return compareValues(cleanedStr, solution, 'text');
                }
                
                const mappedVal = mapExactTrig(cleanedStr);
                if (mappedVal !== undefined) {
                    parsedAnswer = mappedVal;
                } else if (type === 'pi') {
                    parsedAnswer = parsePiFraction(cleanedStr);
                } else {
                    parsedAnswer = parseNumberOrFraction(cleanedStr);
                }

                if (Array.isArray(solution)) {
                    return solution.some(s => compareValues(parsedAnswer, s, type));
                } else {
                    return compareValues(parsedAnswer, solution, type);
                }
            }
            
            // --- SVG GENERATORS (MEJORADOS) ---
            const svgNS = "http://www.w3.org/2000/svg";

            const createSVGElement = (tag, attrs) => {
                const el = document.createElementNS(svgNS, tag);
                for (let key in attrs) {
                    el.setAttribute(key, attrs[key]);
                }
                return el;
            };

            const svgToString = (svgNode) => {
                const serializer = new XMLSerializer();
                return serializer.serializeToString(svgNode);
            };

            function svgUnitCircle({ angleRad = 0, highlightQuadrant = 0, showProjections = false, labels = [], showAngleArc = true }) {
                const svg = createSVGElement('svg', { viewBox: "-1.3 -1.3 2.6 2.6", preserveAspectRatio: "xMidYMid meet" });
                const r = 1;
                const cx = 0, cy = 0;
                const x = r * Math.cos(angleRad);
                const y = -r * Math.sin(angleRad); // SVG y-axis is inverted
                
                // Quadrant highlight
                if (highlightQuadrant > 0) {
                    const quadColors = ['', '#f97316', '#3b82f6', '#ef4444', '#10b981'];
                    const quadAngles = [0, -90, -180, -270];
                    const startAngle = quadAngles[highlightQuadrant - 1];
                    const path = createSVGElement('path', {
                        d: `M 0 0 L 1.2 0 A 1.2 1.2 0 0 1 ${1.2*Math.cos(degToRad(startAngle + 90))} ${-1.2*Math.sin(degToRad(startAngle + 90))} Z`,
                        fill: quadColors[highlightQuadrant],
                        'fill-opacity': '0.15',
                        transform: `rotate(${startAngle})`
                    });
                    svg.appendChild(path);
                }

                // Grid lines
                for (let i = -1; i <= 1; i += 0.5) {
                    if (i !== 0) {
                        svg.appendChild(createSVGElement('line', { 
                            x1: -1.2, y1: i, x2: 1.2, y2: i, 
                            stroke: 'var(--dot-color)', 'stroke-width': 0.01, 'opacity': 0.3 
                        }));
                        svg.appendChild(createSVGElement('line', { 
                            x1: i, y1: -1.2, x2: i, y2: 1.2, 
                            stroke: 'var(--dot-color)', 'stroke-width': 0.01, 'opacity': 0.3 
                        }));
                    }
                }

                // Main axes
                svg.appendChild(createSVGElement('line', { x1: -1.2, y1: 0, x2: 1.2, y2: 0, stroke: '#666', 'stroke-width': 0.02 }));
                svg.appendChild(createSVGElement('line', { x1: 0, y1: -1.2, x2: 0, y2: 1.2, stroke: '#666', 'stroke-width': 0.02 }));
                
                // Circle
                svg.appendChild(createSVGElement('circle', { cx, cy, r, fill: 'none', stroke: 'var(--text-color)', 'stroke-width': 0.03 }));

                // Angle arc (mejorado)
                if (showAngleArc && angleRad !== 0) {
                    const arcRadius = 0.3;
                    const largeArcFlag = Math.abs(angleRad) > Math.PI ? 1 : 0;
                    const sweepFlag = angleRad > 0 ? 0 : 1; // Para que vaya en sentido horario
                    const arcEndX = arcRadius * Math.cos(angleRad);
                    const arcEndY = -arcRadius * Math.sin(angleRad);
                    const arcPath = `M ${arcRadius} 0 A ${arcRadius} ${arcRadius} 0 ${largeArcFlag} ${sweepFlag} ${arcEndX} ${arcEndY}`;
                    svg.appendChild(createSVGElement('path', { 
                        d: arcPath, 
                        fill: 'none', 
                        stroke: 'var(--accent-blue)', 
                        'stroke-width': 0.025,
                        'marker-end': 'url(#arrowhead)'
                    }));
                }

                // Arrow marker definition
                const defs = createSVGElement('defs', {});
                const marker = createSVGElement('marker', {
                    id: 'arrowhead',
                    markerWidth: '10',
                    markerHeight: '7',
                    refX: '9',
                    refY: '3.5',
                    orient: 'auto'
                });
                const polygon = createSVGElement('polygon', {
                    points: '0 0, 10 3.5, 0 7',
                    fill: 'var(--accent-blue)'
                });
                marker.appendChild(polygon);
                defs.appendChild(marker);
                svg.appendChild(defs);

                // Point on circle
                svg.appendChild(createSVGElement('circle', { 
                    cx: x, cy: y, r: 0.04, 
                    fill: 'var(--accent-orange)', 
                    stroke: 'white', 
                    'stroke-width': 0.01 
                }));

                // Radius line
                svg.appendChild(createSVGElement('line', { 
                    x1: cx, y1: cy, x2: x, y2: y, 
                    stroke: 'var(--accent-orange)', 
                    'stroke-width': 0.025 
                }));

                if (showProjections) {
                    // Projection lines (mejoradas)
                    svg.appendChild(createSVGElement('line', { 
                        x1: x, y1: 0, x2: x, y2: y, 
                        stroke: 'var(--accent-green)', 
                        'stroke-width': 0.02, 
                        'stroke-dasharray': '0.05,0.05' 
                    }));
                    svg.appendChild(createSVGElement('line', { 
                        x1: 0, y1: y, x2: x, y2: y, 
                        stroke: 'var(--accent-green)', 
                        'stroke-width': 0.02, 
                        'stroke-dasharray': '0.05,0.05' 
                    }));
                    
                    // Right angle marker
                    svg.appendChild(createSVGElement('path', { 
                        d: `M ${x-0.05} ${y} L ${x-0.05} ${y-0.05} L ${x} ${y-0.05}`, 
                        fill: 'none', 
                        stroke: 'var(--accent-green)', 
                        'stroke-width': 0.015 
                    }));
                }
                
                // Axis labels
                svg.appendChild(createSVGElement('text', { 
                    x: 1.1, y: 0.05, 'font-size': '0.08px', 'text-anchor': 'middle', 
                    fill: 'var(--text-color)', 'font-weight': 'bold' 
                })).textContent = 'x';
                svg.appendChild(createSVGElement('text', { 
                    x: 0.05, y: -1.1, 'font-size': '0.08px', 'text-anchor': 'middle', 
                    fill: 'var(--text-color)', 'font-weight': 'bold' 
                })).textContent = 'y';

                labels.forEach(label => {
                    const text = createSVGElement('text', {
                        x: label.x, y: label.y,
                        'font-size': '0.09px',
                        'text-anchor': 'middle',
                        fill: 'var(--accent-blue)',
                        'font-weight': 'bold',
                    });
                    text.textContent = label.text;
                    svg.appendChild(text);
                });

                return svgToString(svg);
            }

            function svgWave({ func = "sin", A = 1, B = 1, C = 0, D = 0, xRange = [-2 * Math.PI, 2 * Math.PI], highlights = {} }) {
                const svg = createSVGElement('svg', { viewBox: "-120 -80 240 160", preserveAspectRatio: "xMidYMid meet" });
                const [xMin, xMax] = [-110, 110];
                const [yMin, yMax] = [-70, 70];
                const xScale = (xMax - xMin) / (xRange[1] - xRange[0]);
                
                // Mejor escalado para Y
                const maxY = Math.abs(A) + Math.abs(D);
                const yScale = Math.min(60 / (maxY * 1.2), 30);

                const mapX = (x) => (x - xRange[0]) * xScale + xMin;
                const mapY = (y) => -((y - D) * yScale);

                // Grid (mejorado)
                for (let x = Math.ceil(xRange[0]); x <= Math.floor(xRange[1]); x++) {
                    if (x !== 0) {
                        svg.appendChild(createSVGElement('line', { 
                            x1: mapX(x), y1: yMin, x2: mapX(x), y2: yMax, 
                            stroke: '#e5e5e5', 'stroke-width': 0.5, 'opacity': 0.5 
                        }));
                    }
                }

                // Main axes
                const yAxisX = xRange[0] <= 0 && xRange[1] >= 0 ? 0 : C;
                svg.appendChild(createSVGElement('line', { 
                    x1: xMin, y1: mapY(D), x2: xMax, y2: mapY(D), 
                    stroke: '#666', 'stroke-width': 1.5 
                }));
                svg.appendChild(createSVGElement('line', { 
                    x1: mapX(yAxisX), y1: yMin, x2: mapX(yAxisX), y2: yMax, 
                    stroke: '#666', 'stroke-width': 1.5 
                }));
                
                // Ticks mejorados
                const period = (func === 'tan' ? Math.PI : 2 * Math.PI) / Math.abs(B);
                for (let i = -8; i <= 8; i++) {
                    const xTick = C + i * period / 4;
                    if (xTick >= xRange[0] && xTick <= xRange[1]) {
                        svg.appendChild(createSVGElement('line', { 
                            x1: mapX(xTick), y1: mapY(D) - 4, x2: mapX(xTick), y2: mapY(D) + 4, 
                            stroke: 'var(--text-color)', 'stroke-width': 1
                        }));
                    }
                }

                // Wave drawing (mejorado para tangente)
                const steps = 300;
                if (func === 'tan') {
                    const asymptoteSpacing = Math.PI / Math.abs(B);
                    for (let n = Math.floor(xRange[0] / asymptoteSpacing) - 1; n <= Math.ceil(xRange[1] / asymptoteSpacing) + 1; n++) {
                        const start = Math.max(xRange[0], C + n * asymptoteSpacing + 0.01);
                        const end = Math.min(xRange[1], C + (n + 1) * asymptoteSpacing - 0.01);
                        
                        if (start < end) {
                            let points = '';
                            const segmentSteps = Math.ceil(steps * (end - start) / (xRange[1] - xRange[0]));
                            for (let i = 0; i <= segmentSteps; i++) {
                                const x = start + i * (end - start) / segmentSteps;
                                const y = A * Math.tan(B * (x - C)) + D;
                                if (isFinite(y) && Math.abs(y - D) < 100) {
                                    points += `${mapX(x)},${mapY(y)} `;
                                }
                            }
                            if (points.length > 2) {
                                svg.appendChild(createSVGElement('polyline', { 
                                    points, 
                                    fill: 'none', 
                                    stroke: 'var(--accent-orange)', 
                                    'stroke-width': 2.5 
                                }));
                            }
                        }
                    }
                } else {
                    let points = '';
                    for (let i = 0; i <= steps; i++) {
                        const x = xRange[0] + i * (xRange[1] - xRange[0]) / steps;
                        let y;
                        switch(func) {
                            case 'cos': y = A * Math.cos(B * (x - C)) + D; break;
                            default: y = A * Math.sin(B * (x - C)) + D;
                        }
                        points += `${mapX(x)},${mapY(y)} `;
                    }
                    svg.appendChild(createSVGElement('polyline', { 
                        points, 
                        fill: 'none', 
                        stroke: 'var(--accent-orange)', 
                        'stroke-width': 2.5 
                    }));
                }
                
                // Highlights (mejorados)
                if(highlights.amplitude && func !== 'tan') {
                    const peakX = func === 'sin' ? C + period / 4 : C;
                    if (peakX >= xRange[0] && peakX <= xRange[1]) {
                        svg.appendChild(createSVGElement('line', { 
                            x1: mapX(peakX), y1: mapY(D), x2: mapX(peakX), y2: mapY(D+A), 
                            stroke: 'var(--accent-blue)', 'stroke-width': 2, 'stroke-dasharray': '4,4'
                        }));
                        const text = createSVGElement('text', { 
                            x: mapX(peakX)+5, y: mapY(D+A/2), 'font-size': '8px', 
                            fill: 'var(--accent-blue)', 'font-weight': 'bold' 
                        });
                        text.textContent = `A = ${Math.abs(A)}`;
                        svg.appendChild(text);
                    }
                }
                if(highlights.period) {
                    const startX = C;
                    const endX = C + period;
                    if (startX >= xRange[0] && endX <= xRange[1]) {
                        svg.appendChild(createSVGElement('line', { 
                            x1: mapX(startX), y1: mapY(D)-15, x2: mapX(endX), y2: mapY(D)-15, 
                            stroke: 'var(--accent-green)', 'stroke-width': 2
                        }));
                        // Flechas en los extremos
                        svg.appendChild(createSVGElement('polygon', {
                            points: `${mapX(startX)},${mapY(D)-15} ${mapX(startX)+3},${mapY(D)-12} ${mapX(startX)+3},${mapY(D)-18}`,
                            fill: 'var(--accent-green)'
                        }));
                        svg.appendChild(createSVGElement('polygon', {
                            points: `${mapX(endX)},${mapY(D)-15} ${mapX(endX)-3},${mapY(D)-12} ${mapX(endX)-3},${mapY(D)-18}`,
                            fill: 'var(--accent-green)'
                        }));
                        const text = createSVGElement('text', { 
                            x: mapX(startX + period/2), y: mapY(D)-20, 'font-size': '8px', 
                            'text-anchor':'middle', fill: 'var(--accent-green)', 'font-weight': 'bold'
                        });
                        text.textContent = `Per√≠odo = ${highlights.periodLabel}`;
                        svg.appendChild(text);
                    }
                }

                return svgToString(svg);
            }

            function svgRightTriangle({ a, b, c, angleA, angleB, labels }) {
                // Ensure valid triangle
                if (!c) c = Math.sqrt(a*a + b*b);
                if (!a) a = Math.sqrt(c*c - b*b);
                if (!b) b = Math.sqrt(c*c - a*a);
                
                const scale = 120 / Math.max(a, b, c/1.4);
                const width = b * scale + 40;
                const height = a * scale + 40;

                const svg = createSVGElement('svg', { viewBox: `0 0 ${width} ${height}`, preserveAspectRatio: "xMidYMid meet" });
                
                const p1 = {x: 20, y: 20};
                const p2 = {x: 20, y: 20 + a*scale};
                const p3 = {x: 20 + b*scale, y: 20 + a*scale};
                
                // Triangle (mejorado)
                svg.appendChild(createSVGElement('polygon', {
                    points: `${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y}`,
                    fill: 'var(--accent-green)',
                    'fill-opacity': 0.15,
                    stroke: 'var(--text-color)',
                    'stroke-width': 2.5
                }));

                // Right angle marker (mejorado)
                const markerSize = Math.min(15, Math.min(a, b) * scale * 0.2);
                svg.appendChild(createSVGElement('path', { 
                    d: `M ${p2.x} ${p2.y-markerSize} L ${p2.x+markerSize} ${p2.y-markerSize} L ${p2.x+markerSize} ${p2.y}`, 
                    fill: 'none', 
                    stroke: 'var(--accent-blue)', 
                    'stroke-width': 2 
                }));
                
                // Labels (mejorados con mejor posicionamiento)
                if (labels.a) {
                    const textA = createSVGElement('text', { 
                        x: p2.x - 15, y: (p1.y + p2.y)/2 + 3, 
                        'font-size': '14px', 'text-anchor':'middle', 
                        fill: 'var(--accent-orange)', 'font-weight': 'bold' 
                    });
                    textA.textContent = labels.a;
                    svg.appendChild(textA);
                }

                if (labels.b) {
                    const textB = createSVGElement('text', { 
                        x: (p2.x + p3.x)/2, y: p2.y + 20, 
                        'font-size': '14px', 'text-anchor':'middle', 
                        fill: 'var(--accent-orange)', 'font-weight': 'bold' 
                    });
                    textB.textContent = labels.b;
                    svg.appendChild(textB);
                }
                
                if (labels.c) {
                    const textC = createSVGElement('text', { 
                        x: (p1.x + p3.x)/2 + 10, y: (p1.y + p3.y)/2 - 5, 
                        'font-size': '14px', 'text-anchor':'middle', 
                        fill: 'var(--accent-blue)', 'font-weight': 'bold' 
                    });
                    textC.textContent = labels.c;
                    svg.appendChild(textC);
                }

                if (labels.angleA) {
                    const textAngleA = createSVGElement('text', { 
                        x: p1.x+10, y: p1.y+18, 'font-size': '12px', 
                        fill: 'var(--accent-green)', 'font-weight': 'bold' 
                    });
                    textAngleA.textContent = labels.angleA;
                    svg.appendChild(textAngleA);
                }
                if (labels.angleB) {
                    const textAngleB = createSVGElement('text', { 
                        x: p3.x-25, y: p3.y-8, 'font-size': '12px', 
                        fill: 'var(--accent-green)', 'font-weight': 'bold' 
                    });
                    textAngleB.textContent = labels.angleB;
                    svg.appendChild(textAngleB);
                }
                
                return svgToString(svg);
            }

            // --- QUESTION BANK MEJORADA ---
            const questionBank = [
                // Category 1: Unit Circle Values (mejoradas)
                { id: 'uc1', category: 'Circunferencia Unitaria', type: 'numeric', enunciadoTeX: 'Calcula el valor de \\(\\cos(60¬∞)\\).', solution: 0.5, hint: 'El coseno de 60¬∞ corresponde a la coordenada x en la circunferencia unitaria.', svg: () => svgUnitCircle({ angleRad: degToRad(60), showProjections: true, labels: [{text:'cos(60¬∞) = 1/2', x:0.5, y: -0.25}] }) },
                { id: 'uc2', category: 'Circunferencia Unitaria', type: 'numeric', enunciadoTeX: 'Calcula el valor de \\(\\sin(\\pi/6)\\).', solution: 0.5, hint: 'œÄ/6 radianes = 30¬∞. El seno corresponde a la coordenada y.', svg: () => svgUnitCircle({ angleRad: Math.PI/6, showProjections: true, labels: [{text:'œÄ/6', x:0.35, y:-0.15}, {text:'sin(œÄ/6) = 1/2', x:0.7, y:-0.3}] }) },
                { id: 'uc3', category: 'Circunferencia Unitaria', type: 'numeric', enunciadoTeX: 'Calcula el valor de \\(\\tan(\\pi/4)\\).', solution: 1, hint: 'tan(Œ∏) = sin(Œ∏)/cos(Œ∏). En œÄ/4, seno y coseno son iguales.', svg: () => svgUnitCircle({ angleRad: Math.PI/4, showProjections: true, labels: [{text:'œÄ/4', x:0.35, y:-0.15}, {text:'tan(œÄ/4) = 1', x:0.6, y:-0.6}] }) },
                { id: 'uc4', category: 'Circunferencia Unitaria', type: 'numeric', enunciadoTeX: 'Calcula el valor de \\(\\sin(150¬∞)\\).', solution: 0.5, hint: '150¬∞ est√° en el segundo cuadrante, donde el seno es positivo.', svg: () => svgUnitCircle({ angleRad: degToRad(150), highlightQuadrant: 2, showProjections: true, labels: [{text:'150¬∞', x:-0.4, y:-0.15}] }) },
                { id: 'uc5', category: 'Circunferencia Unitaria', type: 'numeric', enunciadoTeX: 'Calcula el valor de \\(\\cos(3\\pi/4)\\).', solution: -Math.sqrt(2)/2, hint: '3œÄ/4 est√° en el segundo cuadrante, donde el coseno es negativo.', svg: () => svgUnitCircle({ angleRad: 3*Math.PI/4, highlightQuadrant: 2, showProjections: true, labels: [{text:'3œÄ/4', x:-0.4, y:-0.15}] }) },
                { id: 'uc6', category: 'Circunferencia Unitaria', type: 'numeric', enunciadoTeX: 'Calcula el valor de \\(\\tan(225¬∞)\\).', solution: 1, hint: '225¬∞ est√° en el tercer cuadrante. Ambos seno y coseno son negativos, por lo que su raz√≥n es positiva.', svg: () => svgUnitCircle({ angleRad: degToRad(225), highlightQuadrant: 3, showProjections: true, labels: [{text:'225¬∞', x:-0.4, y:0.3}] }) },
                { id: 'uc7', category: 'Circunferencia Unitaria', type: 'numeric', enunciadoTeX: 'Calcula el valor de \\(\\cos(\\pi)\\).', solution: -1, hint: 'El √°ngulo œÄ (180¬∞) apunta directamente a la izquierda en el eje x.', svg: () => svgUnitCircle({ angleRad: Math.PI, labels: [{text:'œÄ', x:-0.4, y:-0.1}, {text:'cos(œÄ) = -1', x:-0.7, y:-0.3}] }) },
                { id: 'uc8', category: 'Circunferencia Unitaria', type: 'numeric', enunciadoTeX: 'Calcula el valor de \\(\\sin(3\\pi/2)\\).', solution: -1, hint: 'El √°ngulo 3œÄ/2 (270¬∞) apunta directamente hacia abajo en el eje y.', svg: () => svgUnitCircle({ angleRad: 3*Math.PI/2, labels: [{text:'3œÄ/2', x:0.2, y:0.3}, {text:'sin(3œÄ/2) = -1', x:0.6, y:0.4}] }) },

                // Category 2: Identify function by graph (mejoradas)
                { id: 'graph1', category: 'Identificar Gr√°fica', type: 'text', enunciadoTeX: '¬øQu√© funci√≥n trigonom√©trica representa la gr√°fica mostrada?', solution: 'sin', hint: 'La funci√≥n pasa por el origen (0,0) y comienza subiendo.', svg: () => svgWave({ func: 'sin', xRange: [-Math.PI, 2*Math.PI] }) },
                { id: 'graph2', category: 'Identificar Gr√°fica', type: 'text', enunciadoTeX: '¬øQu√© funci√≥n trigonom√©trica representa la gr√°fica mostrada?', solution: 'cos', hint: 'La funci√≥n alcanza su m√°ximo en x=0.', svg: () => svgWave({ func: 'cos', xRange: [-Math.PI, 2*Math.PI] }) },
                { id: 'graph3', category: 'Identificar Gr√°fica', type: 'text', enunciadoTeX: '¬øQu√© funci√≥n trigonom√©trica representa la gr√°fica mostrada?', solution: 'tan', hint: 'Observa las as√≠ntotas verticales y el comportamiento creciente continuo.', svg: () => svgWave({ func: 'tan', A: 1, B: 1, xRange: [-3*Math.PI/2, 3*Math.PI/2] }) },
                { id: 'graph4', category: 'Identificar Gr√°fica', type: 'text', enunciadoTeX: '¬øCu√°l es la funci√≥n base de esta gr√°fica reflejada verticalmente?', solution: 'sin', hint: 'Es una funci√≥n seno reflejada sobre el eje x (y = -sin(x)).', svg: () => svgWave({ func: 'sin', A: -1, xRange: [-Math.PI, 2*Math.PI] }) },
                { id: 'graph5', category: 'Identificar Gr√°fica', type: 'text', enunciadoTeX: '¬øQu√© funci√≥n base representa esta gr√°fica desplazada horizontalmente?', solution: 'cos', hint: 'Es una funci√≥n coseno desplazada hacia la derecha.', svg: () => svgWave({ func: 'cos', C: Math.PI/2, xRange: [-Math.PI/2, 5*Math.PI/2] }) },
                { id: 'graph6', category: 'Identificar Gr√°fica', type: 'text', enunciadoTeX: '¬øQu√© funci√≥n base est√° desplazada verticalmente?', solution: 'sin', hint: 'La l√≠nea media de la onda no est√° en y=0, pero mantiene la forma del seno.', svg: () => svgWave({ func: 'sin', D: 2, xRange: [-Math.PI, 2*Math.PI] }) },

                // Category 3: Parameters A, B, C, D (mejoradas)
                { id: 'param1', category: 'Par√°metros de Onda', type: 'numeric', enunciadoTeX: 'Dada la gr√°fica de \\(y = A\\sin(x)\\), determina el valor de la amplitud \\(A\\).', solution: 3, hint: 'La amplitud es la distancia m√°xima desde la l√≠nea central hasta un pico.', svg: () => svgWave({ func: 'sin', A: 3, B: 1, xRange: [-Math.PI, 2*Math.PI], highlights: { amplitude: true } }) },
                { id: 'param2', category: 'Par√°metros de Onda', type: 'pi', enunciadoTeX: 'Dada la gr√°fica de \\(y = \\cos(Bx)\\), determina el per√≠odo. (Ingresa en t√©rminos de œÄ, ej. `pi` o `2pi`)', solution: 4*Math.PI, hint: 'El per√≠odo es la longitud de un ciclo completo. Per√≠odo = 2œÄ/B.', svg: () => svgWave({ func: 'cos', A: 1, B: 0.5, xRange: [-Math.PI, 5*Math.PI], highlights: { period: true, periodLabel: '4œÄ' } }) },
                { id: 'param3', category: 'Par√°metros de Onda', type: 'numeric', enunciadoTeX: 'La gr√°fica es de la forma \\(y = \\sin(x) + D\\). ¬øCu√°l es el valor del desplazamiento vertical \\(D\\)?', solution: -1, hint: 'El desplazamiento vertical es el valor de la l√≠nea central (media) de la onda.', svg: () => svgWave({ func: 'sin', D: -1, xRange: [-Math.PI, 2*Math.PI] }) },
                { id: 'param4', category: 'Par√°metros de Onda', type: 'pi', enunciadoTeX: 'La gr√°fica es de la forma \\(y = \\cos(x - C)\\). ¬øCu√°l es el desfase horizontal \\(C\\)? (Ingresa en t√©rminos de œÄ)', solution: Math.PI/2, hint: 'El desfase es el desplazamiento horizontal. Observa d√≥nde comienza el primer m√°ximo del coseno.', svg: () => svgWave({ func: 'cos', C: Math.PI/2, xRange: [-Math.PI/2, 5*Math.PI/2] }) },
                { id: 'param5', category: 'Par√°metros de Onda', type: 'numeric', enunciadoTeX: 'Para la funci√≥n \\(y = A\\sin(2x)\\), determina la amplitud \\(A\\).', solution: 2.5, hint: 'La amplitud es la mitad de la diferencia entre el valor m√°ximo y m√≠nimo.', svg: () => svgWave({ func: 'sin', A: 2.5, B: 2, xRange: [-Math.PI, 2*Math.PI], highlights: { amplitude: true } }) },
                { id: 'param6', category: 'Par√°metros de Onda', type: 'pi', enunciadoTeX: 'Determina el per√≠odo de la funci√≥n mostrada.', solution: Math.PI, hint: 'Cuenta la distancia horizontal entre dos picos consecutivos.', svg: () => svgWave({ func: 'sin', B: 2, xRange: [-Math.PI, 2*Math.PI], highlights: { period: true, periodLabel: 'œÄ' } }) },

                // Category 4: Basic Equations (mejoradas)
                { id: 'eq1', category: 'Ecuaciones Trigonom√©tricas', type: 'pi', enunciadoTeX: 'Encuentra la menor soluci√≥n positiva para \\(\\sin(x) = 1/2\\).', solution: Math.PI/6, hint: 'El seno es 1/2 en œÄ/6 y 5œÄ/6. La menor positiva es œÄ/6.', svg: () => svgUnitCircle({ angleRad: Math.PI/6, highlightQuadrant: 1, labels: [{text:'sin(x) = 1/2', x:0.6, y:-0.5}] }) },
                { id: 'eq2', category: 'Ecuaciones Trigonom√©tricas', type: 'pi', enunciadoTeX: 'Encuentra la soluci√≥n para \\(\\cos(x) = -1\\) en el intervalo \\([0, 2\\pi)\\).', solution: Math.PI, hint: '¬øEn qu√© √°ngulo la coordenada x es -1?', svg: () => svgUnitCircle({ angleRad: Math.PI, labels: [{text:'cos(x) = -1', x:-0.6, y:-0.3}] }) },
                { id: 'eq3', category: 'Ecuaciones Trigonom√©tricas', type: 'pi', enunciadoTeX: 'Encuentra la menor soluci√≥n positiva para \\(\\tan(x) = 1\\).', solution: Math.PI/4, hint: 'La tangente es 1 cuando seno y coseno son iguales en valor absoluto.', svg: () => svgUnitCircle({ angleRad: Math.PI/4, showProjections: true, labels: [{text:'tan(x) = 1', x:0.5, y:-0.5}] }) },
                { id: 'eq4', category: 'Ecuaciones Trigonom√©tricas', type: 'pi', enunciadoTeX: 'Resuelve \\(\\cos(x) = \\sqrt{2}/2\\) en \\([0, \\pi/2]\\).', solution: Math.PI/4, hint: 'Busca un √°ngulo notable en el primer cuadrante donde cos(x) = ‚àö2/2.', svg: () => svgUnitCircle({ angleRad: Math.PI/4, highlightQuadrant: 1, showProjections: true }) },
                { id: 'eq5', category: 'Ecuaciones Trigonom√©tricas', type: 'pi', enunciadoTeX: 'Encuentra la soluci√≥n para \\(\\sin(x) = -1\\) en \\([0, 2\\pi)\\).', solution: 3*Math.PI/2, hint: '¬øEn qu√© √°ngulo la coordenada y es -1?', svg: () => svgUnitCircle({ angleRad: 3*Math.PI/2, labels: [{text:'sin(x) = -1', x:0.3, y:0.4}] }) },
                { id: 'eq6', category: 'Ecuaciones Trigonom√©tricas', type: 'pi', enunciadoTeX: 'Resuelve \\(\\cos(x) = 0\\) para la menor soluci√≥n positiva.', solution: Math.PI/2, hint: 'El coseno es cero cuando el punto est√° en el eje y.', svg: () => svgUnitCircle({ angleRad: Math.PI/2, labels: [{text:'cos(x) = 0', x:0.3, y:-0.3}] }) },

                // Category 5: Right Triangles (mejoradas)
                { id: 'tri1', category: 'Tri√°ngulos Rect√°ngulos', type: 'numeric', enunciadoTeX: 'En el tri√°ngulo rect√°ngulo, calcula la longitud del cateto \\(x\\). Redondea a 2 decimales.', solution: 5.77, hint: 'Usa la tangente: tan(30¬∞) = opuesto/adyacente = 10/x.', svg: () => svgRightTriangle({ a: 10, b: 10/Math.tan(degToRad(30)), c: null, labels: {a: '10', b: 'x', c:'h', angleB: '30¬∞'} }) },
                { id: 'tri2', category: 'Tri√°ngulos Rect√°ngulos', type: 'numeric', enunciadoTeX: 'Calcula la longitud de la hipotenusa \\(h\\). Redondea a 2 decimales.', solution: 14.14, hint: 'Usa el seno: sin(45¬∞) = opuesto/hipotenusa = 10/h.', svg: () => svgRightTriangle({ a: 10, b: 10, c: null, labels: {a: '10', b: '10', c: 'h', angleA: '45¬∞'} }) },
                { id: 'tri3', category: 'Tri√°ngulos Rect√°ngulos', type: 'numeric', enunciadoTeX: 'Calcula la longitud del cateto adyacente \\(y\\). Redondea a 2 decimales.', solution: 8.66, hint: 'Usa el coseno: cos(30¬∞) = adyacente/hipotenusa = y/10.', svg: () => svgRightTriangle({ a: 5, b: 10*Math.cos(degToRad(30)), c: 10, labels: {a: '5', b: 'y', c: '10', angleB: '30¬∞'} }) },
                { id: 'tri4', category: 'Tri√°ngulos Rect√°ngulos', type: 'numeric', enunciadoTeX: 'En un tri√°ngulo rect√°ngulo, si \\(\\sin(\\theta) = 3/5\\) y el cateto opuesto es 3, ¬øcu√°l es la hipotenusa?', solution: 5, hint: 'SOH: Seno = Opuesto / Hipotenusa. Por lo tanto, 3/5 = 3/h.', svg: () => svgRightTriangle({ a: 3, b: 4, c: 5, labels: {a: '3', b: '4', c: '5', angleB: 'Œ∏'} }) },
                { id: 'tri5', category: 'Tri√°ngulos Rect√°ngulos', type: 'numeric', enunciadoTeX: 'Si \\(\\cos(\\theta) = 12/13\\) y el cateto adyacente es 12, ¬øcu√°l es la hipotenusa?', solution: 13, hint: 'CAH: Coseno = Adyacente / Hipotenusa. Por lo tanto, 12/13 = 12/h.', svg: () => svgRightTriangle({ a: 5, b: 12, c: 13, labels: {a: '5', b: '12', c: '13', angleB: 'Œ∏'} }) },
                { id: 'tri6', category: 'Tri√°ngulos Rect√°ngulos', type: 'numeric', enunciadoTeX: 'Si \\(\\tan(\\theta) = 4/3\\) y el cateto opuesto es 8, ¬øcu√°l es el cateto adyacente?', solution: 6, hint: 'TOA: Tangente = Opuesto / Adyacente. Si tan(Œ∏) = 4/3, entonces 8/adyacente = 4/3.', svg: () => svgRightTriangle({ a: 8, b: 6, c: 10, labels: {a: '8', b: '?', c: '10', angleB: 'Œ∏'} }) },

                // Category 6: Applications (mejoradas)
                { id: 'app1', category: 'Aplicaciones', type: 'numeric', enunciadoTeX: 'El voltaje de una se√±al de AC se muestra en la gr√°fica. ¬øCu√°l es la amplitud m√°xima (en voltios)?', solution: 12, hint: 'La amplitud es el valor m√°ximo que alcanza la onda desde la l√≠nea central.', svg: () => svgWave({ func: 'sin', A: 12, D: 0, xRange: [0, 4*Math.PI], highlights: {amplitude:true} }) },
                { id: 'app2', category: 'Aplicaciones', type: 'numeric', enunciadoTeX: 'La gr√°fica muestra el nivel de la marea durante 24 horas. ¬øCu√°l es el per√≠odo de la marea (en horas)?', solution: 12, hint: 'El per√≠odo es el tiempo que tarda en completarse un ciclo completo (de marea alta a marea alta).', svg: () => svgWave({ func: 'cos', B: 2*Math.PI/12, D: 2, xRange: [0, 24], highlights: { period: true, periodLabel: '12h' } }) },
                { id: 'app3', category: 'Aplicaciones', type: 'numeric', enunciadoTeX: 'Una rueda de la fortuna de 30 metros de di√°metro gira. La altura del asiento se muestra en la gr√°fica. ¬øCu√°l es la altura m√≠nima sobre el suelo?', solution: 5, hint: 'La altura m√≠nima es el valor m√≠nimo de la funci√≥n (D - A).', svg: () => svgWave({ func: 'cos', A: -15, B: 1, D: 20, xRange: [0, 4*Math.PI] }) },
                { id: 'app4', category: 'Aplicaciones', type: 'numeric', enunciadoTeX: 'Una funci√≥n seno modela las ventas estacionales. Si el per√≠odo es 12 meses y la venta promedio es 5000 unidades, ¬øcu√°l es la venta promedio?', solution: 5000, hint: 'La venta promedio corresponde al desplazamiento vertical D de la funci√≥n.', svg: () => svgWave({ func: 'sin', A: 1000, B: 2*Math.PI/12, D: 5000, xRange: [0, 24] }) },
                { id: 'app5', category: 'Aplicaciones', type: 'numeric', enunciadoTeX: 'La temperatura diaria oscila como se muestra. ¬øCu√°l es la variaci√≥n m√°xima de temperatura (diferencia entre m√°xima y m√≠nima)?', solution: 16, hint: 'La variaci√≥n m√°xima es el doble de la amplitud (2A).', svg: () => svgWave({ func: 'sin', A: 8, B: 2*Math.PI/24, D: 22, xRange: [0, 48] }) },
                { id: 'app6', category: 'Aplicaciones', type: 'numeric', enunciadoTeX: 'El movimiento de un p√©ndulo se describe por la gr√°fica. ¬øCu√°ntos ciclos completos hace en 8 segundos?', solution: 4, hint: 'Cuenta cu√°ntos ciclos completos caben en el intervalo de tiempo dado.', svg: () => svgWave({ func: 'cos', A: 10, B: Math.PI, D: 0, xRange: [0, 8], highlights: { period: true, periodLabel: '2s' } }) },
            ];

            // --- LOCAL STORAGE ---
            function loadHistory() {
                const storedHistory = localStorage.getItem('examen_trig_historial');
                state.history = storedHistory ? JSON.parse(storedHistory) : [];
                renderHistory();
            }

            function saveHistory() {
                // Keep only the last 5 attempts
                if (state.history.length > 5) {
                    state.history = state.history.slice(state.history.length - 5);
                }
                localStorage.setItem('examen_trig_historial', JSON.stringify(state.history));
                renderHistory();
            }

            // --- RENDER FUNCTIONS ---
            function renderQuestion(question, index) {
                const questionDiv = document.createElement('div');
                questionDiv.className = 'question-card';
                questionDiv.id = `q-${index}`;

                questionDiv.innerHTML = `
                    <div class="question-header">
                        <h3>Pregunta ${index + 1}</h3>
                        <span class="category-badge">${question.category}</span>
                    </div>
                    <div class="question-content">
                        <div class="question-svg">${question.svg()}</div>
                        <div class="question-body">
                            <div class="enunciado">${question.enunciadoTeX}</div>
                            <div class="input-group">
                                <label for="answer-${index}">Respuesta:</label>
                                <input type="text" id="answer-${index}" name="answer-${index}" autocomplete="off" placeholder="Ingresa tu respuesta">
                            </div>
                            <div class="feedback" id="feedback-${index}" aria-live="polite"></div>
                        </div>
                    </div>
                `;
                questionsContainer.appendChild(questionDiv);
            }

            function renderStepper() {
                stepper.innerHTML = '';
                state.currentAttempt.forEach((q, index) => {
                    const li = document.createElement('li');
                    const a = document.createElement('a');
                    a.href = `#q-${index}`;
                    a.innerHTML = `<span class="q-number">${index + 1}</span> <span class="q-text">${q.category}</span>`;
                    a.onclick = (e) => {
                        e.preventDefault();
                        document.getElementById(`q-${index}`).scrollIntoView({behavior: 'smooth'});
                        updateActiveStep(index);
                    };
                    li.appendChild(a);
                    stepper.appendChild(li);
                });
            }

            function updateActiveStep(activeIndex) {
                stepper.querySelectorAll('a').forEach((a, index) => {
                    if (index === activeIndex) {
                        a.classList.add('active');
                        a.setAttribute('aria-current', 'step');
                    } else {
                        a.classList.remove('active');
                        a.removeAttribute('aria-current');
                    }
                });
            }

            function renderHistory() {
                historyBody.innerHTML = '';
                if(state.history.length === 0) {
                    historyBody.innerHTML = `<tr><td colspan="3">No hay intentos guardados.</td></tr>`;
                    return;
                }
                [...state.history].reverse().forEach(attempt => {
                    const row = document.createElement('tr');
                    const date = new Date(attempt.timestamp).toLocaleString('es-PR');
                    row.innerHTML = `
                        <td>${date}</td>
                        <td>${attempt.score}/${attempt.total} (${attempt.percentage}%)</td>
                        <td>${formatTime(attempt.duration)}</td>
                    `;
                    historyBody.appendChild(row);
                });
            }

            function renderGallery() {
                const galleryContainer = document.getElementById('gallery-container');
                const baseFunctions = [
                    { name: '\\(y = \\sin(x)\\)', svg: svgWave({func:'sin', xRange: [-Math.PI, 2*Math.PI]}) },
                    { name: '\\(y = \\cos(x)\\)', svg: svgWave({func:'cos', xRange: [-Math.PI, 2*Math.PI]}) },
                    { name: '\\(y = \\tan(x)\\)', svg: svgWave({func:'tan', A: 1, B: 1, xRange: [-Math.PI, Math.PI]}) },
                ];
                galleryContainer.innerHTML = baseFunctions.map(item => `
                    <div class="gallery-item">
                        <div class="gallery-svg">${item.svg}</div>
                        <p>${item.name}</p>
                    </div>
                `).join('');
            }
            
            // --- EXAM LOGIC ---
            function startExam() {
                state.studentName = studentNameInput.value;
                initialScreen.classList.add('hidden');
                examForm.classList.remove('hidden');
                
                // Select questions
                const questionsByCategory = questionBank.reduce((acc, q) => {
                    if (!acc[q.category]) acc[q.category] = [];
                    acc[q.category].push(q);
                    return acc;
                }, {});

                state.currentAttempt = [];
                const categories = shuffleArray(Object.keys(questionsByCategory));
                for(let i=0; i<NUM_QUESTIONS; i++) {
                    const category = categories[i % categories.length];
                    const availableQuestions = questionsByCategory[category].filter(q => !state.currentAttempt.includes(q));
                    if(availableQuestions.length > 0) {
                        const question = availableQuestions[Math.floor(Math.random() * availableQuestions.length)];
                        state.currentAttempt.push(question);
                    }
                }
                
                state.currentAttempt = shuffleArray(state.currentAttempt);

                questionsContainer.innerHTML = '';
                state.currentAttempt.forEach(renderQuestion);
                renderStepper();
                updateActiveStep(0);
                
                MathJax.typesetPromise();

                state.startTime = new Date();
                state.timerInterval = setInterval(() => {
                    const elapsed = Math.floor((new Date() - state.startTime) / 1000);
                    examTimer.textContent = `Tiempo: ${formatTime(elapsed)}`;
                }, 1000);
                
                // Reset scroll and focus
                window.scrollTo(0, 0);
                document.getElementById('answer-0').focus();
            }

            function submitExam(e) {
                e.preventDefault();
                state.endTime = new Date();
                clearInterval(state.timerInterval);

                let score = 0;
                const results = state.currentAttempt.map((question, index) => {
                    const input = document.getElementById(`answer-${index}`);
                    const userAnswer = input.value;
                    const isCorrect = evaluateAnswer(userAnswer, question.solution, question.type);
                    if (isCorrect) score++;

                    const feedbackDiv = document.getElementById(`feedback-${index}`);
                    feedbackDiv.textContent = (isCorrect ? '‚úÖ Correcta. ' : '‚ùå Incorrecta. ') + question.hint;
                    feedbackDiv.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;
                    
                    const stepperLink = stepper.querySelectorAll('a')[index];
                    stepperLink.classList.add(isCorrect ? 'correct' : 'incorrect');

                    input.disabled = true;
                    return { id: question.id, category: question.category, correct: isCorrect, svg: question.svg(), hint: question.hint, enunciado: question.enunciadoTeX };
                });

                submitBtn.classList.add('hidden');
                examForm.classList.add('hidden');
                resultsSection.classList.remove('hidden');

                const total = state.currentAttempt.length;
                const percentage = Math.round((score / total) * 100);
                const duration = Math.floor((state.endTime - state.startTime) / 1000);

                summaryDiv.innerHTML = `
                    <h3>Resumen del Intento</h3>
                    <p>Has contestado correctamente <strong>${score}</strong> de <strong>${total}</strong> preguntas.</p>
                    <p>Tu puntuaci√≥n es del <strong>${percentage}%</strong>.</p>
                    <p>Tiempo total: <strong>${formatTime(duration)}</strong>.</p>
                `;
                
                const attemptData = {
                    timestamp: state.startTime.toISOString(),
                    score,
                    total,
                    percentage,
                    duration,
                    studentName: state.studentName,
                    results
                };
                
                state.history.push(attemptData);
                saveHistory();
                
                resultsSection.scrollIntoView({ behavior: 'smooth' });
            }

            function retryExam() {
                resultsSection.classList.add('hidden');
                submitBtn.classList.remove('hidden');
                startExam();
            }

            // --- EXPORT & COPY ---
            function getLatestAttempt() {
                return state.history.length > 0 ? state.history[state.history.length - 1] : null;
            }

            function copySummary() {
                const attempt = getLatestAttempt();
                if (!attempt) return;
                const summaryText = `Resumen - Examen de Trigonometr√≠a\n` +
                    (attempt.studentName ? `Estudiante: ${attempt.studentName}\n` : '') +
                    `Fecha: ${new Date(attempt.timestamp).toLocaleString('es-PR')}\n` +
                    `Puntuaci√≥n: ${attempt.score}/${attempt.total} (${attempt.percentage}%)\n` +
                    `Duraci√≥n: ${formatTime(attempt.duration)}`;
                
                navigator.clipboard.writeText(summaryText).then(() => {
                    alert('Resumen copiado al portapapeles.');
                }, () => {
                    alert('Error al copiar el resumen.');
                });
            }

            function downloadFile(filename, content, mimeType) {
                const blob = new Blob([content], { type: mimeType });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }

            function downloadCSV() {
                const attempt = getLatestAttempt();
                if (!attempt) return;
                let csvContent = "pregunta_id;categoria;estado\n";
                attempt.results.forEach(res => {
                    csvContent += `${res.id};${res.category};${res.correct ? 'Correcta' : 'Incorrecta'}\n`;
                });
                downloadFile('resultados_trigonometria.csv', csvContent, 'text/csv;charset=utf-8;');
            }
            
            function downloadJSON() {
                const attempt = getLatestAttempt();
                if (!attempt) return;
                const jsonContent = JSON.stringify(attempt, null, 2);
                downloadFile('resultados_trigonometria.json', jsonContent, 'application/json');
            }

            function downloadPDF() {
                const attempt = getLatestAttempt();
                if (!attempt) return;

                const printContainer = document.getElementById('print-container');
                let content = `<div class="print-header"><h1>Resultados del Examen de Trigonometr√≠a</h1>`;
                if(attempt.studentName) content += `<p><strong>Estudiante:</strong> ${attempt.studentName}</p>`;
                content += `<p><strong>Fecha:</strong> ${new Date(attempt.timestamp).toLocaleString('es-PR')}</p>`;
                content += `<p><strong>Puntuaci√≥n:</strong> ${attempt.score}/${attempt.total} (${attempt.percentage}%)</p></div>`;

                attempt.results.forEach((res, index) => {
                    content += `<div class="print-question">
                        <h3>Pregunta ${index + 1}: ${res.enunciado}</h3>
                        ${res.svg}
                        <p><strong>Estado:</strong> ${res.correct ? 'Correcta' : 'Incorrecta'}</p>
                        <p><strong>Pista:</strong> ${res.hint}</p>
                    </div>`;
                });

                printContainer.innerHTML = content;
                MathJax.typesetPromise([printContainer]).then(() => {
                    window.print();
                    printContainer.innerHTML = '';
                });
            }

            // --- INITIALIZATION ---
            function init() {
                // Event Listeners
                startBtn.addEventListener('click', startExam);
                examForm.addEventListener('submit', submitExam);
                retryBtn.addEventListener('click', retryExam);
                copySummaryBtn.addEventListener('click', copySummary);
                csvBtn.addEventListener('click', downloadCSV);
                jsonBtn.addEventListener('click', downloadJSON);
                pdfBtn.addEventListener('click', downloadPDF);
                
                // Intersection Observer for active step
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const index = parseInt(entry.target.id.split('-')[1]);
                            updateActiveStep(index);
                        }
                    });
                }, { rootMargin: "-50% 0px -50% 0px" });

                document.querySelectorAll('.question-card').forEach(card => observer.observe(card));
                // Re-observe after new exam starts
                const observerConfig = { childList: true };
                const observerCallback = (mutationsList, obs) => {
                    for(const mutation of mutationsList) {
                        if (mutation.type === 'childList') {
                            document.querySelectorAll('.question-card').forEach(card => observer.observe(card));
                        }
                    }
                };
                const mutationObserver = new MutationObserver(observerConfig);
                mutationObserver.observe(questionsContainer, observerConfig);

                loadHistory();
                renderGallery();
                MathJax.typesetPromise();
            }

            init();

        })();
    });
    </script>
</body>
</html>