<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <title>Examen de Resolución de Triángulos</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root {
            --color-bg: #121212;
            --color-panel: #1f1f1f;
            --color-text: #e0e0e0;
            --color-accent-cyan: #64ffda;
            --color-accent-green: #ccff90;
            --color-accent-red: #ff8a80;
            --color-border: #333333;
            --color-drawing-bg: #f5f5f5;
            --color-drawing-lines: #212121;
            --shadow-subtle: 0 2px 8px rgba(0, 0, 0, 0.4);
            --radius: 0.75rem;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--color-bg);
            color: var(--color-text);
            margin: 0;
            padding: 2rem;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            width: 100%;
            max-width: 900px;
            background-color: var(--color-panel);
            border: 1px solid var(--color-border);
            border-radius: var(--radius);
            box-shadow: var(--shadow-subtle);
            padding: 1.5rem;
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        .tab-buttons {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            background-color: var(--color-panel);
            padding: 0.5rem;
            border-radius: var(--radius);
        }

        .tab-button {
            flex: 1;
            padding: 0.75rem;
            border: none;
            background-color: transparent;
            color: var(--color-text);
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
        }

        .tab-button:hover {
            background-color: var(--color-border);
        }

        .tab-button.active {
            background-color: var(--color-accent-cyan);
            color: var(--color-panel);
            font-weight: bold;
            box-shadow: 0 0 15px var(--color-accent-cyan);
        }

        h1, h2 {
            text-align: center;
            color: var(--color-accent-cyan);
            font-weight: 300;
        }
        
        h2 { margin-top: 0; }

        .form-group {
            margin-bottom: 1rem;
        }

        input[type="text"], input[type="number"], .input-group > input, .input-group > select, .input-group > .unit-toggle-group {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--color-border);
            border-radius: var(--radius);
            background-color: var(--color-bg);
            color: var(--color-text);
            box-sizing: border-box;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1rem;
        }
        
        input:focus, select:focus, button:focus, .unit-toggle-group:focus-within {
            outline: none;
            border-color: var(--color-accent-cyan);
            box-shadow: 0 0 0 3px rgba(100, 255, 218, 0.5);
        }
        
        .question-card {
            background-color: var(--color-panel);
            border: 1px solid var(--color-border);
            border-radius: var(--radius);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: var(--shadow-subtle);
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .question-header h3 {
            margin: 0;
            color: var(--color-accent-green);
        }

        .question-feedback {
            margin-top: 0.75rem;
            padding: 0.75rem;
            border-radius: var(--radius);
            border: 1px solid transparent;
            font-weight: 500;
        }

        .question-feedback.correct {
            background-color: rgba(204, 255, 144, 0.1);
            border-color: var(--color-accent-green);
            color: var(--color-accent-green);
        }
        .question-feedback.incorrect {
            background-color: rgba(255, 138, 128, 0.1);
            border-color: var(--color-accent-red);
            color: var(--color-accent-red);
        }

        .quiz-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            margin-top: 2rem;
        }

        .button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--radius);
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .button-primary {
            background-color: var(--color-accent-cyan);
            color: var(--color-panel);
        }

        .button-primary:hover {
            background-color: #40c0b8;
        }

        .button-secondary {
            background-color: var(--color-accent-green);
            color: var(--color-panel);
        }
        
        .button-secondary:hover {
            background-color: #a5d378;
        }
        
        .button-coral {
            background-color: var(--color-accent-red);
            color: var(--color-panel);
        }

        .button-coral:hover {
            background-color: #d1756d;
        }
        
        .results-section {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .results-summary {
            background-color: var(--color-panel);
            border: 1px solid var(--color-border);
            padding: 1rem;
            border-radius: var(--radius);
            text-align: center;
        }

        .results-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
        }

        #history-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .history-item {
            background-color: var(--color-bg);
            border: 1px solid var(--color-border);
            padding: 1rem;
            border-radius: var(--radius);
        }
        
        .svg-container {
            width: 100%;
            max-width: 500px;
            height: 350px;
            margin: 1.5rem auto;
            border: 1px solid var(--color-border);
            border-radius: var(--radius);
            background-color: var(--color-drawing-bg);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
        }

        .svg-container svg {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .input-group label {
            white-space: nowrap;
        }
        
        .unit-toggle-group {
            display: flex;
            border: 1px solid var(--color-border);
            border-radius: var(--radius);
            overflow: hidden;
            background-color: var(--color-bg);
            padding: 0;
        }
        
        .unit-toggle-group input[type="radio"] {
            display: none;
        }
        
        .unit-toggle-group label {
            flex: 1;
            text-align: center;
            padding: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            border-right: 1px solid var(--color-border);
            font-size: 0.8rem;
            font-weight: bold;
            color: var(--color-text);
        }
        
        .unit-toggle-group label:last-child {
            border-right: none;
        }
        
        .unit-toggle-group input[type="radio"]:checked + label {
            background-color: var(--color-accent-cyan);
            color: var(--color-panel);
        }

        .question-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 1.5rem;
        }

        .correct-icon { color: var(--color-accent-green); }
        .incorrect-icon { color: var(--color-accent-red); }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        table th, table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--color-border);
        }

        table th {
            background-color: var(--color-bg);
            font-weight: bold;
            color: var(--color-accent-cyan);
        }

        @media screen and (max-width: 600px) {
            body { padding: 1rem; }
            .tab-buttons, .quiz-controls, .results-controls { flex-direction: column; }
            .question-grid { grid-template-columns: 1fr; }
            .svg-container { height: 300px; }
        }

        @media print {
            body {
                background: none !important;
                color: #000 !important;
                padding: 0 !important;
                margin: 0;
                font-size: 12pt;
                text-shadow: none;
            }

            .container, .tab-buttons, .tab-panel.active, .quiz-controls, .results-controls, .form-group, .history-section, .quiz-summary {
                display: none !important;
            }
            
            .print-view {
                display: block !important;
                width: 100%;
                margin: 0 auto;
                padding: 1rem;
                color: #000;
            }

            .print-view h2, .print-view h3 { color: #000; }
            .print-view .question-card {
                border: 1px solid #ccc;
                box-shadow: none;
                background-color: #fff;
                padding: 1rem;
                margin-bottom: 1rem;
            }

            .print-view .question-card .svg-container {
                border: 1px solid #ccc;
                background-color: #f8f8f8;
            }

            .question-card .question-feedback {
                background-color: #f0f0f0;
                border-color: #ccc;
                color: #000;
            }
        }

    </style>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']],
                displayMath: [['\\[', '\\]']]
            },
            svg: { 
                fontCache: 'global',
                scale: 1.2
            },
            startup: {
                ready: () => {
                    MathJax.startup.defaultReady();
                    console.log('MathJax ready');
                    window.dispatchEvent(new CustomEvent('mathjax-ready'));
                }
            }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>
<body>
    <div class="container" id="main-app">
        <h1 class="text-center">Examen de Resolución de Triángulos</h1>
        <div class="tab-buttons">
            <button class="tab-button active" onclick="app.showTab('instructions')">Instrucciones</button>
            <button class="tab-button" onclick="app.showTab('quiz')">Examen</button>
            <button class="tab-button" onclick="app.showTab('results')">Resultados</button>
        </div>
        
        <div id="instructions-tab" class="tab-panel active">
            <h2>Instrucciones</h2>
            <p>Este examen evalúa su habilidad para resolver triángulos. Se generarán 12 preguntas aleatorias de diferentes categorías. Puede intentarlo cuantas veces quiera.</p>
            <ul>
                <li><strong>No hay límite de tiempo.</strong></li>
                <li>Las preguntas pueden pedirle que encuentre longitudes de lados o medidas de ángulos.</li>
                <li>Utilice los campos de entrada especiales para ángulos y longitudes. Los ángulos aceptan Grados, Radianes o el formato DMS. Las longitudes aceptan números decimales o fracciones (ej: <code>7/2</code>).</li>
                <li>Cuando envíe sus respuestas, el sistema le dirá si su respuesta fue correcta o incorrecta y le proporcionará una pista, pero <strong>nunca le revelará la respuesta correcta</strong>.</li>
            </ul>
            <div class="form-group">
                <label for="student-name">Su nombre (opcional):</label>
                <input type="text" id="student-name" placeholder="Ej: Juan Pérez" />
            </div>
            <div class="quiz-controls">
                <button class="button button-primary" onclick="app.startQuiz()">Iniciar Examen</button>
            </div>
        </div>

        <div id="quiz-tab" class="tab-panel">
            <h2>Examen</h2>
            <p id="quiz-status" aria-live="polite">Preguntas respondidas: 0/12</p>
            <form id="quiz-form" onsubmit="event.preventDefault(); app.evaluateQuiz()">
                <div id="questions-container" class="question-grid"></div>
                <div class="quiz-controls">
                    <button type="submit" class="button button-secondary">Enviar Respuestas</button>
                    <button type="button" class="button button-coral" onclick="app.startQuiz()">Reintentar</button>
                </div>
            </form>
        </div>

        <div id="results-tab" class="tab-panel">
            <h2>Resultados</h2>
            <div id="results-summary" class="results-summary"></div>
            <div id="results-table"></div>
            <div class="results-controls">
                <button class="button button-primary" onclick="app.startQuiz()">Tomar Otro Intento</button>
                <button class="button button-primary" onclick="app.exportCSV()">Descargar CSV</button>
                <button class="button button-primary" onclick="app.exportJSON()">Descargar JSON</button>
                <button class="button button-primary" onclick="app.exportPDF()">Descargar PDF</button>
                <button class="button button-primary" onclick="app.copySummary()">Copiar Resumen</button>
            </div>

            <h3>Historial de Intentos</h3>
            <ul id="history-list"></ul>
        </div>
    </div>
    <div class="print-view" id="print-view"></div>

    <script>
        const app = (() => {
            const state = {
                activeTab: 'instructions',
                quiz: [],
                score: { correct: 0, total: 0 },
                quizHistory: [],
                studentName: '',
                startTime: null
            };

            const selectors = {
                app: document.getElementById('main-app'),
                tabs: document.querySelectorAll('.tab-button'),
                panels: document.querySelectorAll('.tab-panel'),
                quizContainer: document.getElementById('questions-container'),
                quizStatus: document.getElementById('quiz-status'),
                resultsSummary: document.getElementById('results-summary'),
                resultsTable: document.getElementById('results-table'),
                historyList: document.getElementById('history-list'),
                studentNameInput: document.getElementById('student-name')
            };

            const tolerances = {
                angle: 1e-4, // radians
                length: 1e-4
            };

            const DEG_TO_RAD = Math.PI / 180;
            const RAD_TO_DEG = 180 / Math.PI;
            const clamp = (val, min, max) => Math.max(min, Math.min(val, max));

            // Utility functions
            const deg2rad = (deg) => deg * DEG_TO_RAD;
            const rad2deg = (rad) => rad * RAD_TO_DEG;
            const toFixedTrim = (num, precision = 4) => parseFloat(num.toFixed(precision));
            const generateUUID = () => crypto.randomUUID();
            const formatDuration = (seconds) => {
                const min = Math.floor(seconds / 60);
                const sec = Math.floor(seconds % 60);
                return `${min}m ${sec}s`;
            };

            const parsers = {
                parseFraction: (str) => {
                    if (str.includes('/')) {
                        const [num, den] = str.split('/').map(Number);
                        return den !== 0 ? num / den : NaN;
                    }
                    return parseFloat(str);
                },
                parseDMS: (str) => {
                    const parts = str.match(/^(-?\d+)°(?:(\d+)'(?:(\d+)")?)?$/);
                    if (!parts) return NaN;
                    let sign = parts[1] < 0 ? -1 : 1;
                    let deg = Math.abs(Number(parts[1]));
                    let min = Number(parts[2] || 0);
                    let sec = Number(parts[3] || 0);
                    return sign * (deg + min / 60 + sec / 3600);
                },
                parsePi: (str) => {
                    str = str.replace(/\s/g, '').toLowerCase();
                    if (!str.includes('pi')) return parseFloat(str);
                    str = str.replace('π', 'pi');
                    if (str === 'pi') return Math.PI;
                    if (str.startsWith('pi/')) return Math.PI / Number(str.substring(3));
                    if (str.endsWith('/pi')) return Number(str.substring(0, str.length - 3)) / Math.PI;
                    if (str.includes('*pi/')) {
                        const [num, den] = str.split('*pi/').map(Number);
                        return num * Math.PI / den;
                    }
                    if (str.includes('pi/')) {
                         const [num, den] = str.split('pi/').map(Number);
                        return num * Math.PI / den;
                    }
                    return parseFloat(str.replace('pi', '')) * Math.PI;
                }
            };
            
            const evaluateAngle = (userVal, correctVal) => {
                let parsedVal;
                const unit = userVal.unit;
                const text = userVal.value;

                if (unit === 'dms') parsedVal = parsers.parseDMS(text);
                else if (unit === 'rad') parsedVal = parsers.parsePi(text);
                else parsedVal = parsers.parseFraction(text);

                if (unit === 'deg') parsedVal = deg2rad(parsedVal);

                if (isNaN(parsedVal)) return false;
                
                return Math.abs(parsedVal - correctVal) <= tolerances.angle;
            };

            const evaluateLength = (userVal, correctVal) => {
                const parsedVal = parsers.parseFraction(userVal);
                if (isNaN(parsedVal)) return false;
                return Math.abs(parsedVal - correctVal) <= tolerances.length;
            };

            const evaluateClassification = (userVal, correctVal) => {
                return userVal === correctVal;
            };
            
            // SVG Generators - Fixed for proper centering
            const drawBlueprintGrid = (width, height) => {
                let gridSvg = '';
                const gridColor = '#6a6a8a';
                const gridSize = Math.min(width, height) / 20;
                
                for (let i = 0; i <= width; i += gridSize) {
                    gridSvg += `<line x1="${i}" y1="0" x2="${i}" y2="${height}" stroke="${gridColor}" stroke-width="0.5" opacity="0.3"/>`;
                }
                for (let i = 0; i <= height; i += gridSize) {
                    gridSvg += `<line x1="0" y1="${i}" x2="${width}" y2="${i}" stroke="${gridColor}" stroke-width="0.5" opacity="0.3"/>`;
                }
                return gridSvg;
            };
            
            const svgRightTriangle = ({ a, b, c, A, B, C }) => {
                const width = 400;
                const height = 300;
                const margin = 60;
                
                // Scale factor to fit triangle in viewport
                const maxSide = Math.max(a, b);
                const scale = Math.min((width - 2*margin) / maxSide, (height - 2*margin) / maxSide);
                
                // Position vertices
                const scaledA = a * scale;
                const scaledB = b * scale;
                
                const p1 = { x: margin, y: height - margin }; // Bottom-left (C)
                const p2 = { x: margin + scaledB, y: height - margin }; // Bottom-right (B)
                const p3 = { x: margin, y: height - margin - scaledA }; // Top-left (A)
                
                return `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">
                    <rect x="0" y="0" width="${width}" height="${height}" fill="var(--color-drawing-bg)"/>
                    <polygon points="${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y}" 
                             fill="#b3e5fc" stroke="var(--color-drawing-lines)" stroke-width="2"/>
                    
                    <!-- Right angle indicator -->
                    <path d="M${p1.x + 15},${p1.y} L${p1.x + 15},${p1.y - 15} L${p1.x},${p1.y - 15}" 
                          fill="none" stroke="#f44336" stroke-width="2"/>
                    
                    <!-- Vertex labels -->
                    <text x="${p1.x - 15}" y="${p1.y + 20}" font-size="16" fill="var(--color-drawing-lines)" font-weight="bold">C</text>
                    <text x="${p2.x + 10}" y="${p2.y + 20}" font-size="16" fill="var(--color-drawing-lines)" font-weight="bold">B</text>
                    <text x="${p3.x - 15}" y="${p3.y - 5}" font-size="16" fill="var(--color-drawing-lines)" font-weight="bold">A</text>
                    
                    <!-- Side labels -->
                    <text x="${(p1.x + p2.x) / 2}" y="${p1.y + 25}" font-size="14" fill="#2e7d32" font-weight="bold" text-anchor="middle">b</text>
                    <text x="${p1.x - 30}" y="${(p1.y + p3.y) / 2}" font-size="14" fill="#2e7d32" font-weight="bold" text-anchor="middle">a</text>
                    <text x="${(p2.x + p3.x) / 2 + 20}" y="${(p2.y + p3.y) / 2}" font-size="14" fill="#2e7d32" font-weight="bold" text-anchor="middle">c</text>
                </svg>`;
            };

            const svgObliqueTriangle = ({ a, b, c, A, B, C, highlightA, highlightB, highlightC, highlightArcA, highlightArcB, highlightArcC }) => {
                const width = 400;
                const height = 300;
                const margin = 60;
                
                // Calculate proper triangle placement
                const scale = Math.min((width - 2*margin) / Math.max(a, b, c), (height - 2*margin) / Math.max(a, b, c)) * 0.8;
                
                const p1 = { x: margin, y: height - margin }; // C
                const p2 = { x: margin + b * scale, y: height - margin }; // B
                const p3 = { 
                    x: margin + c * scale * Math.cos(deg2rad(A)), 
                    y: height - margin - c * scale * Math.sin(deg2rad(A))
                }; // A
                
                return `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">
                    <rect x="0" y="0" width="${width}" height="${height}" fill="var(--color-drawing-bg)"/>
                    <polygon points="${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y}" 
                             fill="#b3e5fc" stroke="var(--color-drawing-lines)" stroke-width="2"/>
                    
                    <!-- Vertex labels -->
                    <text x="${p1.x - 15}" y="${p1.y + 20}" font-size="16" fill="var(--color-drawing-lines)" font-weight="bold">C</text>
                    <text x="${p2.x + 10}" y="${p2.y + 20}" font-size="16" fill="var(--color-drawing-lines)" font-weight="bold">B</text>
                    <text x="${p3.x}" y="${p3.y - 10}" font-size="16" fill="var(--color-drawing-lines)" font-weight="bold" text-anchor="middle">A</text>
                    
                    <!-- Side labels -->
                    <text x="${(p1.x + p2.x) / 2}" y="${p1.y + 25}" font-size="14" fill="#2e7d32" font-weight="bold" text-anchor="middle">c</text>
                    <text x="${(p2.x + p3.x) / 2 + 15}" y="${(p2.y + p3.y) / 2}" font-size="14" fill="#2e7d32" font-weight="bold" text-anchor="middle">a</text>
                    <text x="${(p1.x + p3.x) / 2 - 15}" y="${(p1.y + p3.y) / 2}" font-size="14" fill="#2e7d32" font-weight="bold" text-anchor="middle">b</text>
                    
                    <!-- Angle arcs -->
                    ${highlightArcA ? `<path d="M${p3.x+25},${p3.y} A25,25 0 0,0 ${p3.x - 18},${p3.y + 18}" fill="none" stroke="#f44336" stroke-width="2"/>` : ''}
                    ${highlightArcB ? `<path d="M${p2.x-25},${p2.y} A25,25 0 0,1 ${p2.x - 18},${p2.y - 18}" fill="none" stroke="#f44336" stroke-width="2"/>` : ''}
                    ${highlightArcC ? `<path d="M${p1.x+25},${p1.y} A25,25 0 0,0 ${p1.x + 18},${p1.y - 18}" fill="none" stroke="#f44336" stroke-width="2"/>` : ''}
                </svg>`;
            };

            const svgSSAHeight = ({ a, b, A, h }) => {
                const width = 400;
                const heightSvg = 300;
                const margin = 60;
                
                const scale = Math.min((width - 2*margin) / Math.max(b, h), (heightSvg - 2*margin) / Math.max(b, h)) * 0.7;
                
                const p1 = { x: margin, y: heightSvg - margin }; // Vertex C
                const p2 = { x: p1.x + b * scale, y: p1.y }; // Vertex B (on line)
                const p3 = { 
                    x: p1.x + b * scale * Math.cos(deg2rad(A)), 
                    y: p1.y - b * scale * Math.sin(deg2rad(A))
                }; // Vertex A
                const p4 = { x: p3.x, y: p1.y }; // Base of height
                
                return `<svg width="${width}" height="${heightSvg}" viewBox="0 0 ${width} ${heightSvg}" xmlns="http://www.w3.org/2000/svg">
                    <rect x="0" y="0" width="${width}" height="${heightSvg}" fill="var(--color-drawing-bg)"/>
                    
                    <!-- Base line extended -->
                    <line x1="${margin - 20}" y1="${p1.y}" x2="${width - margin + 20}" y2="${p1.y}" stroke="#4caf50" stroke-width="2"/>
                    
                    <!-- Known sides -->
                    <line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="var(--color-drawing-lines)" stroke-width="2"/>
                    <line x1="${p1.x}" y1="${p1.y}" x2="${p3.x}" y2="${p3.y}" stroke="#2196f3" stroke-width="3"/>
                    
                    <!-- Height line -->
                    <line x1="${p3.x}" y1="${p3.y}" x2="${p4.x}" y2="${p4.y}" stroke="#f44336" stroke-width="2" stroke-dasharray="3,3"/>
                    
                    <!-- Arc showing possible triangle positions -->
                    <circle cx="${p1.x}" cy="${p1.y}" r="${a * scale}" fill="none" stroke="#ff9800" stroke-width="2" stroke-dasharray="5,5" opacity="0.8"/>
                    
                    <!-- Angle arc at C -->
                    <path d="M${p1.x + 20},${p1.y} A20,20 0 0,0 ${p1.x + 14},${p1.y - 14}" fill="none" stroke="#2196f3" stroke-width="2"/>
                    
                    <!-- Right angle indicator for height -->
                    <path d="M${p4.x - 10},${p4.y} L${p4.x - 10},${p4.y - 10} L${p4.x},${p4.y - 10}" fill="none" stroke="#f44336" stroke-width="2"/>
                    
                    <!-- Labels -->
                    <text x="${p1.x - 15}" y="${p1.y + 20}" font-size="16" fill="var(--color-drawing-lines)" font-weight="bold">C</text>
                    <text x="${p2.x + 10}" y="${p2.y + 20}" font-size="16" fill="var(--color-drawing-lines)" font-weight="bold">B</text>
                    <text x="${p3.x}" y="${p3.y - 10}" font-size="16" fill="var(--color-drawing-lines)" font-weight="bold" text-anchor="middle">A</text>
                    
                    <!-- Measurements -->
                    <text x="${(p1.x + p3.x) / 2 - 15}" y="${(p1.y + p3.y) / 2}" font-size="14" fill="#2196f3" font-weight="bold">b = ${b}</text>
                    <text x="${p4.x + 10}" y="${(p3.y + p4.y) / 2}" font-size="14" fill="#f44336" font-weight="bold">h = ${h}</text>
                    
                    <!-- Arc label -->
                    <text x="${p1.x + a * scale * 0.7}" y="${p1.y - 15}" font-size="14" fill="#ff9800" font-weight="bold">a = ${a}</text>
                    
                    <!-- Angle label -->
                    <text x="${p1.x + 25}" y="${p1.y - 5}" font-size="14" fill="#2196f3" font-weight="bold">A = ${A}°</text>
                    
                    <!-- Instruction text -->
                    <text x="${width/2}" y="${margin/2}" font-size="12" fill="#666" text-anchor="middle" font-style="italic">
                        Comparar: a vs h determina el número de soluciones
                    </text>
                </svg>`;
            };

            const svgElevation = ({ a, b, A, problemType = 'depression' }) => {
                const width = 400;
                const heightSvg = 300;
                const margin = 60;
                
                // Scale factor to fit the drawing
                const maxDim = Math.max(a || b, b);
                const scale = Math.min((width - 2*margin) / maxDim, (heightSvg - 2*margin) / maxDim) * 0.7;
                
                let p1, p2, p3, angleDirection;
                
                if (problemType === 'ladder') {
                    // Ladder against wall problem
                    p1 = { x: margin, y: heightSvg - margin }; // Base of ladder
                    p2 = { x: margin + b * scale, y: heightSvg - margin }; // Base of wall
                    p3 = { x: margin + b * scale, y: heightSvg - margin - a * scale }; // Top of ladder against wall
                    angleDirection = 1; // elevation
                } else {
                    // Airplane depression problem
                    p1 = { x: margin, y: heightSvg - margin - a * scale }; // Airplane
                    p2 = { x: margin, y: heightSvg - margin }; // Ground point below airplane
                    p3 = { x: margin + b * scale, y: heightSvg - margin }; // Airport
                    angleDirection = -1; // depression
                }
                
                return `<svg width="${width}" height="${heightSvg}" viewBox="0 0 ${width} ${heightSvg}" xmlns="http://www.w3.org/2000/svg">
                    <rect x="0" y="0" width="${width}" height="${heightSvg}" fill="var(--color-drawing-bg)"/>
                    
                    ${problemType === 'ladder' ? `
                        <!-- Wall -->
                        <rect x="${p2.x}" y="${margin}" width="8" height="${heightSvg - 2*margin}" fill="#8d6e63" stroke="var(--color-drawing-lines)" stroke-width="1"/>
                        
                        <!-- Ladder -->
                        <line x1="${p1.x}" y1="${p1.y}" x2="${p3.x}" y2="${p3.y}" stroke="#ff9800" stroke-width="4"/>
                        
                        <!-- Ground -->
                        <line x1="${margin - 20}" y1="${p1.y}" x2="${p2.x + 20}" y2="${p1.y}" stroke="var(--color-drawing-lines)" stroke-width="2"/>
                        
                        <!-- Right angle at wall base -->
                        <path d="M${p2.x - 15},${p2.y} L${p2.x - 15},${p2.y - 15} L${p2.x},${p2.y - 15}" fill="none" stroke="#f44336" stroke-width="2"/>
                        
                        <!-- Angle at ladder base -->
                        <path d="M${p1.x + 25},${p1.y} A25,25 0 0,0 ${p1.x + 18},${p1.y - 18}" fill="none" stroke="#f44336" stroke-width="2"/>
                        
                        <!-- Labels -->
                        <text x="${(p1.x + p3.x) / 2 - 15}" y="${(p1.y + p3.y) / 2 - 5}" font-size="14" fill="#ff9800" font-weight="bold" transform="rotate(${-Math.atan2(a * scale, b * scale) * 180 / Math.PI} ${(p1.x + p3.x) / 2} ${(p1.y + p3.y) / 2})">escalera</text>
                        <text x="${(p1.x + p2.x) / 2}" y="${p1.y + 20}" font-size="14" fill="#2e7d32" font-weight="bold" text-anchor="middle">${toFixedTrim(b)}m</text>
                        <text x="${p2.x + 15}" y="${(p2.y + p3.y) / 2}" font-size="14" fill="#2e7d32" font-weight="bold">altura</text>
                        <text x="${p1.x + 30}" y="${p1.y - 10}" font-size="14" fill="#f44336" font-weight="bold">θ</text>
                    ` : `
                        <!-- Ground line -->
                        <line x1="${margin - 20}" y1="${p2.y}" x2="${width - margin + 20}" y2="${p2.y}" stroke="#4caf50" stroke-width="3"/>
                        
                        <!-- Airplane -->
                        <polygon points="${p1.x-8},${p1.y-3} ${p1.x+8},${p1.y-3} ${p1.x+5},${p1.y+3} ${p1.x-5},${p1.y+3}" fill="#2196f3" stroke="var(--color-drawing-lines)" stroke-width="1"/>
                        
                        <!-- Airport (tower) -->
                        <rect x="${p3.x-5}" y="${p3.y-20}" width="10" height="20" fill="#ff5722" stroke="var(--color-drawing-lines)" stroke-width="1"/>
                        
                        <!-- Vertical altitude line -->
                        <line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="#9c27b0" stroke-width="2" stroke-dasharray="3,3"/>
                        
                        <!-- Horizontal distance line -->
                        <line x1="${p2.x}" y1="${p2.y}" x2="${p3.x}" y2="${p3.y}" stroke="#2e7d32" stroke-width="2"/>
                        
                        <!-- Line of sight -->
                        <line x1="${p1.x}" y1="${p1.y}" x2="${p3.x}" y2="${p3.y}" stroke="#f44336" stroke-width="2" stroke-dasharray="5,5"/>
                        
                        <!-- Horizontal reference line for angle -->
                        <line x1="${p1.x}" y1="${p1.y}" x2="${p1.x + 40}" y2="${p1.y}" stroke="var(--color-drawing-lines)" stroke-width="1" stroke-dasharray="2,2"/>
                        
                        <!-- Angle arc for depression -->
                        <path d="M${p1.x + 25},${p1.y} A25,25 0 0,1 ${p1.x + 18},${p1.y + 18}" fill="none" stroke="#f44336" stroke-width="2"/>
                        
                        <!-- Right angle indicators -->
                        <path d="M${p2.x - 10},${p2.y} L${p2.x - 10},${p2.y - 10} L${p2.x},${p2.y - 10}" fill="none" stroke="#9c27b0" stroke-width="1"/>
                        <path d="M${p3.x - 10},${p3.y} L${p3.x - 10},${p3.y - 10} L${p3.x},${p3.y - 10}" fill="none" stroke="#2e7d32" stroke-width="1"/>
                        
                        <!-- Labels -->
                        <text x="${p1.x}" y="${p1.y - 15}" font-size="12" fill="#2196f3" font-weight="bold" text-anchor="middle">Avión</text>
                        <text x="${p3.x}" y="${p3.y + 35}" font-size="12" fill="#ff5722" font-weight="bold" text-anchor="middle">Aeropuerto</text>
                        <text x="${p2.x - 25}" y="${(p1.y + p2.y) / 2}" font-size="14" fill="#9c27b0" font-weight="bold">${toFixedTrim(a)}m</text>
                        <text x="${(p2.x + p3.x) / 2}" y="${p2.y + 20}" font-size="14" fill="#2e7d32" font-weight="bold" text-anchor="middle">${toFixedTrim(b)}m</text>
                        <text x="${p1.x + 30}" y="${p1.y + 15}" font-size="14" fill="#f44336" font-weight="bold">θ</text>
                    `}
                </svg>`;
            };


            const angleInputHTML = (name) => `
                <div class="input-group">
                    <label for="${name}">\\(${name}\\):</label>
                    <input type="text" id="${name}" name="${name}" placeholder="ej: 30.5 o 30°30'0&quot;">
                    <div class="unit-toggle-group" role="radiogroup" aria-labelledby="${name}-label">
                        <input type="radio" id="${name}-deg" name="${name}-unit" value="deg" checked>
                        <label for="${name}-deg">°</label>
                        <input type="radio" id="${name}-rad" name="${name}-unit" value="rad">
                        <label for="${name}-rad">rad</label>
                        <input type="radio" id="${name}-dms" name="${name}-unit" value="dms">
                        <label for="${name}-dms">DMS</label>
                    </div>
                </div>
            `;
            
            const lengthInputHTML = (name) => `
                <div class="input-group">
                    <label for="${name}">\\(${name}\\):</label>
                    <input type="text" id="${name}" name="${name}" placeholder="ej: 50.2 o 7/2">
                </div>
            `;

            // Question Bank Generators
            const questionGenerators = {
                rightTriangle: () => {
                    const a = toFixedTrim(Math.random() * 50 + 5);
                    const b = toFixedTrim(Math.random() * 50 + 5);
                    const A = rad2deg(Math.atan(a/b));
                    const B = 90 - A;
                    const c = Math.sqrt(a*a + b*b);
                    const solutions = { a, b, c, A: deg2rad(A), B: deg2rad(B), C: deg2rad(90) };
                    
                    const types = [
                        { fields: ['c'], given: { a, B }, text: `Dado \\(a=${a}\\) y \\(B=${toFixedTrim(B)}°\\), halla el lado \\(c\\).`},
                        { fields: ['A'], given: { b, c }, text: `Dado \\(b=${b}\\) y \\(c=${toFixedTrim(c)}\\), halla el ángulo \\(A\\).`},
                        { fields: ['a'], given: { c, A }, text: `Dado \\(c=${toFixedTrim(c)}\\) y \\(A=${toFixedTrim(A)}°\\), halla el lado \\(a\\).`},
                    ];
                    const type = types[Math.floor(Math.random() * types.length)];

                    return {
                        id: generateUUID(), category: 'Triángulos Rectángulos',
                        enunciadoTeX: type.text, tipo: 'normal',
                        campos: type.fields.map(f => ({ clave: f, tipo: f.length === 1 ? 'angulo' : 'lado'})),
                        solucionCanonica: solutions,
                        pista: 'Usa SOH-CAH-TOA.',
                        svg: svgRightTriangle({ a: a, b: b, c: c, A: A, B: B, C: 90, ...type.given })
                    };
                },
                lawOfSines: () => {
                    const A_deg = toFixedTrim(Math.random() * 40 + 20);
                    const C_deg = toFixedTrim(Math.random() * 40 + 20);
                    const B_deg = 180 - A_deg - C_deg;
                    const A_rad = deg2rad(A_deg);
                    const C_rad = deg2rad(C_deg);
                    const B_rad = deg2rad(B_deg);
                    const c = toFixedTrim(Math.random() * 50 + 10);
                    const a = c * Math.sin(A_rad) / Math.sin(C_rad);
                    const b = c * Math.sin(B_rad) / Math.sin(C_rad);
                    const solutions = { a, b, c, A: A_rad, B: B_rad, C: C_rad };

                    const types = [
                        { fields: ['a'], given: { A: A_deg, C: C_deg, c }, text: `Encuentra el lado \\(a\\) si \\(A=${toFixedTrim(A_deg)}°\\), \\(C=${toFixedTrim(C_deg)}°\\) y \\(c=${c}\\).`},
                        { fields: ['B'], given: { A: A_deg, a, b }, text: `Halla el ángulo \\(B\\) si \\(A=${toFixedTrim(A_deg)}°\\), \\(a=${toFixedTrim(a)}\\) y \\(b=${toFixedTrim(b)}\\).`},
                        { fields: ['c'], given: { B: B_deg, C: C_deg, b }, text: `Halla \\(c\\) si \\(B=${toFixedTrim(B_deg)}°\\), \\(C=${toFixedTrim(C_deg)}°\\) y \\(b=${toFixedTrim(b)}\\).`},
                    ];
                    const type = types[Math.floor(Math.random() * types.length)];
                    return {
                        id: generateUUID(), category: 'Ley de Senos (AAS/ASA)',
                        enunciadoTeX: type.text, tipo: 'normal',
                        campos: type.fields.map(f => ({ clave: f, tipo: f.length === 1 ? 'angulo' : 'lado'})),
                        solucionCanonica: solutions,
                        pista: 'La Ley de Senos relaciona lados y ángulos opuestos: \\(\\frac{a}{\\sin A} = \\frac{b}{\\sin B}\\).',
                        svg: svgObliqueTriangle({ a, b, c, A: A_deg, B: B_deg, C: C_deg, highlightArcA: type.given.A !== undefined, highlightArcB: type.given.B !== undefined, highlightArcC: type.given.C !== undefined })
                    };
                },
                lawOfCosinesSAS: () => {
                    const a = toFixedTrim(Math.random() * 50 + 10);
                    const b = toFixedTrim(Math.random() * 50 + 10);
                    const C_deg = toFixedTrim(Math.random() * 80 + 20);
                    const C_rad = deg2rad(C_deg);
                    const c = Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(C_rad));
                    const A_rad = Math.acos(clamp((b * b + c * c - a * a) / (2 * b * c), -1, 1));
                    const B_rad = Math.acos(clamp((a * a + c * c - b * b) / (2 * a * c), -1, 1));
                    const solutions = { a, b, c, A: A_rad, B: B_rad, C: C_rad };
                    
                    const types = [
                        { fields: ['c'], text: `Encuentra el lado \\(c\\) si \\(a=${a}\\), \\(b=${b}\\) y el ángulo \\(C=${C_deg}°\\).`},
                        { fields: ['B'], text: `Halla el ángulo \\(B\\) si \\(a=${a}\\), \\(b=${b}\\) y el ángulo \\(C=${C_deg}°\\).`},
                    ];
                    const type = types[Math.floor(Math.random() * types.length)];
                    
                    return {
                        id: generateUUID(), category: 'Ley de Cosenos (SAS)',
                        enunciadoTeX: type.text, tipo: 'normal',
                        campos: type.fields.map(f => ({ clave: f, tipo: f.length === 1 ? 'angulo' : 'lado'})),
                        solucionCanonica: solutions,
                        pista: 'Usa la Ley de Cosenos para el lado faltante, luego Ley de Senos o Cosenos para los ángulos.',
                        svg: svgObliqueTriangle({ a, b, c, A: rad2deg(A_rad), B: rad2deg(B_rad), C: C_deg, highlightArcC: true })
                    };
                },
                lawOfCosinesSSS: () => {
                    let a, b, c;
                    do {
                        a = toFixedTrim(Math.random() * 40 + 20);
                        b = toFixedTrim(Math.random() * 40 + 20);
                        c = toFixedTrim(Math.random() * 40 + 20);
                    } while (a + b <= c || a + c <= b || b + c <= a);

                    const A_rad = Math.acos(clamp((b * b + c * c - a * a) / (2 * b * c), -1, 1));
                    const B_rad = Math.acos(clamp((a * a + c * c - b * b) / (2 * a * c), -1, 1));
                    const C_rad = Math.PI - A_rad - B_rad;
                    const solutions = { a, b, c, A: A_rad, B: B_rad, C: C_rad };
                    
                    const fieldsToFind = ['A', 'B', 'C'][Math.floor(Math.random() * 3)];
                    const text = `Halla el ángulo \\(${fieldsToFind}\\) si los lados del triángulo son \\(a=${a}\\), \\(b=${b}\\) y \\(c=${c}\\).`;
                    
                    return {
                        id: generateUUID(), category: 'Ley de Cosenos (SSS)',
                        enunciadoTeX: text, tipo: 'normal',
                        campos: [{ clave: fieldsToFind, tipo: 'angulo' }],
                        solucionCanonica: solutions,
                        pista: 'Usa la Ley de Cosenos para encontrar un ángulo.',
                        svg: svgObliqueTriangle({ a, b, c, A: rad2deg(A_rad), B: rad2deg(B_rad), C: rad2deg(C_rad) })
                    };
                },
                ambiguousCase: () => {
                    const b = toFixedTrim(Math.random() * 40 + 20, 2);
                    const A_deg = toFixedTrim(Math.random() * 60 + 15, 2);
                    const A_rad = deg2rad(A_deg);
                    const h = b * Math.sin(A_rad);
                    let a, solutionType;

                    // Determine solution type first, then set 'a' accordingly
                    const rand = Math.random();
                    if (rand < 0.33) {
                        // 0 solutions: a < h
                        solutionType = '0';
                        a = toFixedTrim(Math.random() * (h * 0.8) + h * 0.1, 2);
                    } else if (rand < 0.66) {
                        // 1 solution: a = h or a >= b
                        solutionType = '1';
                        if (Math.random() < 0.5) {
                            a = toFixedTrim(h, 2);
                        } else {
                            a = toFixedTrim(Math.random() * 15 + b + 2, 2);
                        }
                    } else {
                        // 2 solutions: h < a < b
                        solutionType = '2';
                        const range = b - h;
                        if (range > 1) {
                            a = toFixedTrim(h + Math.random() * (range * 0.8) + range * 0.1, 2);
                        } else {
                            // Fallback if range is too small
                            a = toFixedTrim(h + 0.5, 2);
                        }
                    }
                    
                    const text = `Halla el número de soluciones si \\(a=${a}\\), \\(b=${b}\\) y \\(A=${A_deg}°\\).`;
                    
                    let hint;
                    if (solutionType === '0') {
                        hint = 'Compara el lado opuesto \'a\' con la altura \'h\'. Si \\(a < h\\), no hay solución.';
                    } else if (solutionType === '1') {
                        hint = 'Si \\(a = h\\) o \\(a \\ge b\\) y \\(a > h\\), hay una solución única.';
                    } else {
                        hint = 'Si \\(h < a < b\\) hay dos soluciones posibles para el ángulo opuesto a \'b\'.';
                    }
                    
                    return {
                        id: generateUUID(), category: 'Caso Ambiguo (SSA)',
                        enunciadoTeX: text, tipo: 'clasificacion',
                        campos: [{ clave: 'solutions', tipo: 'clasificacion' }],
                        solucionCanonica: solutionType,
                        pista: hint,
                        svg: svgSSAHeight({ a, b, A: A_deg, h: toFixedTrim(h, 2) })
                    };
                },
                applied: () => {
                    const A_deg = toFixedTrim(Math.random() * 60 + 15, 1);
                    const A_rad = deg2rad(A_deg);
                    const b = toFixedTrim(Math.random() * 80 + 30, 1); // More realistic distances
                    const a = toFixedTrim(b * Math.tan(A_rad), 1);
                    const c = toFixedTrim(b / Math.cos(A_rad), 1);
                    const solutions = { a, b, c, A: A_rad };
                    
                    const problemTypes = [
                        { 
                            fields: ['a'], 
                            text: `Desde un punto en el suelo a \\(${b}\\) metros de un edificio, el ángulo de elevación a la cima es de \\(${A_deg}°\\). ¿Cuál es la altura del edificio?`,
                            svgType: 'building'
                        },
                        { 
                            fields: ['A'], 
                            text: `Una escalera de \\(${c}\\) metros de largo se apoya contra una pared. Si la base de la escalera está a \\(${b}\\) metros de la pared, ¿cuál es el ángulo de elevación?`,
                            svgType: 'ladder'
                        },
                        { 
                            fields: ['A'], 
                            text: `Un avión vuela a una altura de \\(${a}\\) metros. Si la distancia horizontal a un aeropuerto es de \\(${b}\\) metros, ¿cuál es el ángulo de depresión desde el avión al aeropuerto?`,
                            svgType: 'depression'
                        }
                    ];
                    
                    const type = problemTypes[Math.floor(Math.random() * problemTypes.length)];

                    return {
                        id: generateUUID(), category: 'Problemas Aplicados',
                        enunciadoTeX: type.text, tipo: 'normal',
                        campos: type.fields.map(f => ({ clave: f, tipo: f.length === 1 ? 'angulo' : 'lado'})),
                        solucionCanonica: solutions,
                        pista: 'Dibuja el triángulo rectángulo y aplica SOH-CAH-TOA.',
                        svg: svgElevation({ 
                            a: a, 
                            b: b, 
                            A: A_deg, 
                            problemType: type.svgType === 'ladder' ? 'ladder' : 'airplane'
                        })
                    };
                }
            };

            const allQuestionCategories = Object.keys(questionGenerators);
            
            const generateQuiz = () => {
                const quiz = [];
                const itemsPerCategory = Math.floor(12 / allQuestionCategories.length);
                let remaining = 12 - itemsPerCategory * allQuestionCategories.length;
                
                const shuffledCategories = allQuestionCategories.sort(() => 0.5 - Math.random());
                
                shuffledCategories.forEach(category => {
                    const count = itemsPerCategory + (remaining-- > 0 ? 1 : 0);
                    for (let i = 0; i < count; i++) {
                        quiz.push(questionGenerators[category]());
                    }
                });

                state.quiz = quiz.sort(() => 0.5 - Math.random());
                renderQuiz();
            };

            const renderQuiz = () => {
                selectors.quizContainer.innerHTML = '';
                state.quiz.forEach((q, index) => {
                    const card = document.createElement('div');
                    card.className = 'question-card';
                    card.dataset.id = q.id;
                    card.innerHTML = `
                        <div class="question-header">
                            <h3>Pregunta ${index + 1}</h3>
                            <small>${q.category}</small>
                        </div>
                        <p class="question-enunciado">${q.enunciadoTeX}</p>
                        <div class="svg-container">${q.svg}</div>
                        <div class="question-inputs">
                            ${q.campos.map(f => {
                                if (f.tipo === 'angulo') {
                                    return angleInputHTML(f.clave);
                                } else if (f.tipo === 'lado') {
                                    return lengthInputHTML(f.clave);
                                } else if (f.tipo === 'clasificacion') {
                                    return `
                                        <div class="input-group">
                                            <label for="${f.clave}">Clasificación:</label>
                                            <select id="${f.clave}" name="${f.clave}">
                                                <option value="">Seleccione</option>
                                                <option value="0">0 soluciones</option>
                                                <option value="1">1 solución</option>
                                                <option value="2">2 soluciones</option>
                                            </select>
                                        </div>
                                    `;
                                }
                            }).join('')}
                        </div>
                        <div class="question-feedback" id="feedback-${q.id}" aria-live="polite"></div>
                    `;
                    selectors.quizContainer.appendChild(card);
                });
                updateQuizStatus();
                
                // Render MathJax after DOM is updated
                if (window.MathJax && window.MathJax.typesetPromise) {
                    window.MathJax.typesetPromise().catch(err => console.log('MathJax error:', err));
                }
            };

            const updateQuizStatus = () => {
                const answeredCount = state.quiz.filter(q => q.answered).length;
                selectors.quizStatus.textContent = `Preguntas respondidas: ${answeredCount}/${state.quiz.length}`;
            };
            
            const evaluateQuiz = () => {
                let correctCount = 0;
                let totalCount = 0;
                
                state.quiz.forEach(q => {
                    const feedbackEl = document.getElementById(`feedback-${q.id}`);
                    feedbackEl.innerHTML = '';
                    let isCorrect = true;
                    
                    q.campos.forEach(campo => {
                        const inputElement = document.getElementById(campo.clave);
                        let userValue;
                        if (campo.tipo === 'angulo') {
                            const unitElement = document.querySelector(`input[name="${campo.clave}-unit"]:checked`);
                            userValue = { value: inputElement.value, unit: unitElement.value };
                            if (!evaluateAngle(userValue, q.solucionCanonica[campo.clave])) { isCorrect = false; }
                        } else if (campo.tipo === 'lado') {
                            userValue = inputElement.value;
                            if (!evaluateLength(userValue, q.solucionCanonica[campo.clave])) { isCorrect = false; }
                        } else if (campo.tipo === 'clasificacion') {
                            userValue = inputElement.value;
                            if (!evaluateClassification(userValue, q.solucionCanonica)) { isCorrect = false; }
                        }
                    });

                    q.answered = true;
                    q.isCorrect = isCorrect;
                    
                    feedbackEl.className = `question-feedback ${isCorrect ? 'correct' : 'incorrect'}`;
                    feedbackEl.innerHTML = `
                        <strong>Respuesta:</strong> ${isCorrect ? 'Correcta' : 'Incorrecta'}.
                        <br>
                        <strong>Pista:</strong> ${q.pista}
                    `;
                    
                    if (isCorrect) correctCount++;
                    totalCount++;
                });

                state.score = { correct: correctCount, total: totalCount };
                
                const attempt = {
                    id: generateUUID(),
                    timestamp: new Date().toLocaleString('es-PR', { timeZone: 'America/Puerto_Rico' }),
                    duration_sec: Math.floor((Date.now() - state.startTime) / 1000),
                    total: state.score.total,
                    correctas: state.score.correct,
                    incorrectas: state.score.total - state.score.correct,
                    porcentaje: toFixedTrim((state.score.correct / state.score.total) * 100),
                    detalle: state.quiz.map(q => ({ id: q.id, categoria: q.category, estado: q.isCorrect ? 'Correcta' : 'Incorrecta', pista: q.pista })),
                    studentName: state.studentName
                };

                state.quizHistory.unshift(attempt);
                if (state.quizHistory.length > 5) {
                    state.quizHistory.pop();
                }
                localStorage.setItem('examen_triangulos_historial', JSON.stringify(state.quizHistory));

                renderResults();
                showTab('results');
                updateQuizStatus();
            };

            const renderResults = () => {
                const latestAttempt = state.quizHistory[0];
                if (!latestAttempt) {
                    selectors.resultsSummary.textContent = 'No hay intentos registrados.';
                    selectors.resultsTable.innerHTML = '';
                    return;
                }
                
                const resumenHTML = `
                    <h3>Resumen del último intento</h3>
                    <p><strong>Nombre:</strong> ${latestAttempt.studentName || 'Anónimo'}</p>
                    <p><strong>Fecha y hora:</strong> ${latestAttempt.timestamp}</p>
                    <p><strong>Duración:</strong> ${formatDuration(latestAttempt.duration_sec)}</p>
                    <p><strong>Resultados:</strong> ${latestAttempt.correctas}/${latestAttempt.total} preguntas correctas.</p>
                    <p><strong>Porcentaje:</strong> ${latestAttempt.porcentaje}%</p>
                `;
                selectors.resultsSummary.innerHTML = resumenHTML;
                
                const tableHTML = `
                    <table>
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Categoría</th>
                                <th>Estado</th>
                                <th>Pista</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${latestAttempt.detalle.map((d, i) => `
                                <tr>
                                    <td>${i + 1}</td>
                                    <td>${d.categoria}</td>
                                    <td>
                                        <span class="${d.estado === 'Correcta' ? 'correct-icon' : 'incorrect-icon'}">
                                            ${d.estado === 'Correcta' ? '✓' : '✗'}
                                        </span>
                                        ${d.estado}
                                    </td>
                                    <td>${d.pista}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                `;
                selectors.resultsTable.innerHTML = tableHTML;
                renderHistory();
            };

            const renderHistory = () => {
                selectors.historyList.innerHTML = state.quizHistory.map(attempt => `
                    <li class="history-item">
                        <strong>Intento:</strong> ${attempt.timestamp}
                        <br>
                        <strong>Resultados:</strong> ${attempt.correctas}/${attempt.total} (${attempt.porcentaje}%)
                        <br>
                        <strong>Duración:</strong> ${formatDuration(attempt.duration_sec)}
                    </li>
                `).join('');
            };

            const showTab = (tabId) => {
                selectors.panels.forEach(p => p.classList.remove('active'));
                selectors.tabs.forEach(b => b.classList.remove('active'));
                document.getElementById(`${tabId}-tab`).classList.add('active');
                document.querySelector(`.tab-button[onclick="app.showTab('${tabId}')"]`).classList.add('active');
            };

            const startQuiz = () => {
                state.studentName = selectors.studentNameInput.value.trim();
                state.startTime = Date.now();
                generateQuiz();
                showTab('quiz');
            };

            const exportCSV = () => {
                const latestAttempt = state.quizHistory[0];
                if (!latestAttempt) return;
                const header = `timestamp;intento;total;correctas;incorrectas;porcentaje;duracion_seg;detalle_por_pregunta`;
                const details = latestAttempt.detalle.map(d => `${d.categoria}: ${d.estado}`).join(' | ');
                const row = `${latestAttempt.timestamp};1;${latestAttempt.total};${latestAttempt.correctas};${latestAttempt.incorrectas};${latestAttempt.porcentaje};${latestAttempt.duration_sec};"${details}"`;
                const csvContent = `data:text/csv;charset=utf-8,${encodeURIComponent(header + '\n' + row)}`;
                const link = document.createElement('a');
                link.setAttribute('href', csvContent);
                link.setAttribute('download', `examen-resultados-${Date.now()}.csv`);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };

            const exportJSON = () => {
                const latestAttempt = state.quizHistory[0];
                if (!latestAttempt) return;
                const jsonContent = `data:application/json;charset=utf-8,${encodeURIComponent(JSON.stringify(latestAttempt, null, 2))}`;
                const link = document.createElement('a');
                link.setAttribute('href', jsonContent);
                link.setAttribute('download', `examen-resultados-${Date.now()}.json`);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };

            const exportPDF = () => {
                const printView = document.getElementById('print-view');
                const latestAttempt = state.quizHistory[0];
                if (!latestAttempt) return;
                
                printView.innerHTML = `
                    <div style="font-family: sans-serif;">
                        <h2>Examen de Resolución de Triángulos</h2>
                        <p><strong>Estudiante:</strong> ${latestAttempt.studentName || 'Anónimo'}</p>
                        <p><strong>Fecha:</strong> ${latestAttempt.timestamp}</p>
                        <hr>
                        <h3>Resumen</h3>
                        <p><strong>Resultados:</strong> ${latestAttempt.correctas}/${latestAttempt.total} (${latestAttempt.porcentaje}%)</p>
                        <p><strong>Duración:</strong> ${formatDuration(latestAttempt.duration_sec)}</p>
                        <hr>
                        <h3>Detalle por Pregunta</h3>
                        ${state.quiz.map((q, i) => `
                            <div class="question-card">
                                <div class="question-header">
                                    <h4>Pregunta ${i + 1}</h4>
                                    <small>${q.category}</small>
                                </div>
                                <p>${q.enunciadoTeX}</p>
                                <div class="svg-container">${q.svg}</div>
                                <div class="question-feedback ${q.isCorrect ? 'correct' : 'incorrect'}">
                                    <strong>Estado:</strong> ${q.isCorrect ? 'Correcta' : 'Incorrecta'}.
                                    <br>
                                    <strong>Pista:</strong> ${q.pista}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
                window.print();
            };
            
            const copySummary = () => {
                const latestAttempt = state.quizHistory[0];
                if (!latestAttempt) return;
                const summaryText = `Resumen del Examen de Triángulos:\nNombre: ${latestAttempt.studentName || 'Anónimo'}\nFecha: ${latestAttempt.timestamp}\nResultados: ${latestAttempt.correctas}/${latestAttempt.total} (${latestAttempt.porcentaje}%)\nDuración: ${formatDuration(latestAttempt.duration_sec)}`;
                navigator.clipboard.writeText(summaryText)
                    .then(() => alert('Resumen copiado al portapapeles.'))
                    .catch(err => console.error('Failed to copy text: ', err));
            };

            const init = () => {
                const storedHistory = localStorage.getItem('examen_triangulos_historial');
                if (storedHistory) {
                    state.quizHistory = JSON.parse(storedHistory);
                }
                renderHistory();
                selectors.studentNameInput.addEventListener('input', (e) => {
                    state.studentName = e.target.value;
                });
            };

            return { showTab, startQuiz, evaluateQuiz, exportCSV, exportJSON, exportPDF, copySummary, init };

        })();

        window.onload = app.init;
    </script>
</body>
</html>